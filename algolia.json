[{"author":null,"categories":["Tech"],"content":"Rich Sutton의 'The Bitter Lesson'을 한국어로 요약합니다. 인간 지식 주입의 한계와 컴퓨팅·학습 중심 접근의 우월성을 정리합니다.","date":1761405061,"description":"Rich Sutton의 'The Bitter Lesson'을 한국어로 요약합니다. 인간 지식 주입의 한계와 컴퓨팅·학습 중심 접근의 우월성을 정리합니다.","dir":"post/","excerpt_html":"Rich Sutton의 'The Bitter Lesson'을 한국어로 요약합니다. 인간 지식 주입의 한계와 컴퓨팅·학습 중심 접근의 우월성을 정리합니다.","excerpt_text":"Rich Sutton의 'The Bitter Lesson'을 한국어로 요약합니다. 인간 지식 주입의 한계와 컴퓨팅·학습 중심 접근의 우월성을 정리합니다.","expirydate":-62135596800,"fuzzywordcount":900,"html":"Rich Sutton의 'The Bitter Lesson'을 한국어로 요약합니다. 인간 지식 주입의 한계와 컴퓨팅·학습 중심 접근의 우월성을 정리합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1761405061,"objectID":"7a3dc1066e80f4385cae00a83616ce88","permalink":"https://hybridego.github.io/2025/10/26/The-Bitter-Lesson/","publishdate":"2025-10-26T00:11:01+09:00","readingtime":2,"relpermalink":"/2025/10/26/The-Bitter-Lesson/","section":"post","summary":"\u003ch3 id=\"리치-서튼의-쓴-교훈the-bitter-lesson-요약\"\u003e리치 서튼의 \u0026ldquo;쓴 교훈(The Bitter Lesson)\u0026rdquo; 요약\u003c/h3\u003e\n\u003cp\u003e리치 서튼(Rich Sutton)이 2019년에 발표한 이 에세이는 AI 연구 70년의 역사를 바탕으로 한 핵심 교훈을 다룬다. \u003cstrong\u003e주요 논지\u003c/strong\u003e: AI 개발에서 인간 지식이나 도메인 전문성을 시스템에 주입하는 접근은 단기적으로 효과적일 수 있지만, 장기적으로는 계산 능력(무어의 법칙에 따른 컴퓨팅 파워 증가)을 활용한 일반적 방법(검색과 학습)이 훨씬 우월하다. 인간 중심의 \u0026ldquo;지능\u0026quot;을 모방하려는 시도는 연구를 복잡하게 만들고 진척을 막지만, 컴퓨팅 스케일링에 의존하는 방법은 세계의 복잡성을 스스로 발견하며 지속적으로 발전한다.\u003c/p\u003e","tags":["AI","Machine Learning","Rich Sutton","Bitter Lesson","Research"],"title":"The Bitter Lesson","type":"post","url":"/2025/10/26/The-Bitter-Lesson/","weight":0,"wordcount":876},{"author":null,"categories":["Tech"],"content":"usleep, sleep으로 time 해상도를 체크 해봅니다. 시스템에서 최대 시간 해상도를 확인해봅니다.","date":1760662515,"description":"usleep, sleep으로 time 해상도를 체크 해봅니다. 시스템에서 최대 시간 해상도를 확인해봅니다.","dir":"post/","excerpt_html":"usleep, sleep으로 time 해상도를 체크 해봅니다. 시스템에서 최대 시간 해상도를 확인해봅니다.","excerpt_text":"usleep, sleep으로 time 해상도를 체크 해봅니다. 시스템에서 최대 시간 해상도를 확인해봅니다.","expirydate":-62135596800,"fuzzywordcount":500,"html":"usleep, sleep으로 time 해상도를 체크 해봅니다. 시스템에서 최대 시간 해상도를 확인해봅니다.","keywords":null,"kind":"page","lang":"en","lastmod":1760662515,"objectID":"372753fc592840d3610a6009cca6eb95","permalink":"https://hybridego.github.io/2025/10/17/sleep-time-check/","publishdate":"2025-10-17T10:10:05+09:00","readingtime":1,"relpermalink":"/2025/10/17/sleep-time-check/","section":"post","summary":"\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e#include \u0026lt;iostream\u0026gt;\r\n#include \u0026lt;unistd.h\u0026gt;\r\n#include \u0026lt;ctime\u0026gt;\r\n#include \u0026lt;chrono\u0026gt;\r\n\r\nint main() {\r\n    // 현재 시간을 마이크로초 단위로 가져오는 함수\r\n    auto getCurrentMicros = []() {\r\n        return std::chrono::duration_cast\u0026lt;std::chrono::microseconds\u0026gt;(\r\n            std::chrono::high_resolution_clock::now().time_since_epoch()\r\n        ).count();\r\n    };\r\n\r\n    // 여러 대기 시간을 테스트\r\n    int waitTimes[] = {100000, 500000, 1000000}; // 0.1초, 0.5초, 1초\r\n\r\n    for (int waitTime : waitTimes) {\r\n        std::cout \u0026lt;\u0026lt; \u0026#34;대기 시작: \u0026#34; \u0026lt;\u0026lt; waitTime \u0026lt;\u0026lt; \u0026#34; 마이크로초\u0026#34; \u0026lt;\u0026lt; std::endl;\r\n\r\n        // 시작 시간 기록\r\n        long long startTime = getCurrentMicros();\r\n\r\n        // usleep 호출\r\n        usleep(waitTime);\r\n\r\n        // 종료 시간 기록\r\n        long long endTime = getCurrentMicros();\r\n\r\n        // 실제 경과 시간 계산\r\n        long long elapsedTime = endTime - startTime;\r\n\r\n        std::cout \u0026lt;\u0026lt; \u0026#34;예상 대기 시간: \u0026#34; \u0026lt;\u0026lt; waitTime \u0026lt;\u0026lt; \u0026#34; 마이크로초\u0026#34; \u0026lt;\u0026lt; std::endl;\r\n        std::cout \u0026lt;\u0026lt; \u0026#34;실제 대기 시간: \u0026#34; \u0026lt;\u0026lt; elapsedTime \u0026lt;\u0026lt; \u0026#34; 마이크로초\u0026#34; \u0026lt;\u0026lt; std::endl;\r\n        std::cout \u0026lt;\u0026lt; \u0026#34;차이: \u0026#34; \u0026lt;\u0026lt; elapsedTime - waitTime \u0026lt;\u0026lt; \u0026#34; 마이크로초\u0026#34; \u0026lt;\u0026lt; std::endl;\r\n        std::cout \u0026lt;\u0026lt; \u0026#34;------------------------\u0026#34; \u0026lt;\u0026lt; std::endl;\r\n    }\r\n\r\n    return 0;\r\n}\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch2 id=\"좀-더-개선\"\u003e좀 더 개선\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e#include \u0026lt;iostream\u0026gt;\r\n#include \u0026lt;chrono\u0026gt;\r\n#include \u0026lt;thread\u0026gt;\r\n#include \u0026lt;iomanip\u0026gt;\r\n\r\n// 시간 측정을 위한 헬퍼 함수\r\ntemplate\u0026lt;typename Func\u0026gt;\r\nlong long measureTime(Func func) {\r\n    auto start = std::chrono::high_resolution_clock::now();\r\n    func();\r\n    auto end = std::chrono::high_resolution_clock::now();\r\n    return std::chrono::duration_cast\u0026lt;std::chrono::nanoseconds\u0026gt;(end - start).count();\r\n}\r\n\r\nvoid testSleep(const std::string\u0026amp; name, auto duration) {\r\n    long long elapsed = measureTime([\u0026amp;]() {\r\n        std::this_thread::sleep_for(duration);\r\n    });\r\n\r\n    std::cout \u0026lt;\u0026lt; std::left \u0026lt;\u0026lt; std::setw(15) \u0026lt;\u0026lt; name\r\n              \u0026lt;\u0026lt; \u0026#34; 요청 시간: \u0026#34; \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; duration.count()\r\n              \u0026lt;\u0026lt; \u0026#34; 실제 시간: \u0026#34; \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; elapsed\r\n              \u0026lt;\u0026lt; \u0026#34; ns (차이: \u0026#34; \u0026lt;\u0026lt; elapsed - duration.count() \u0026lt;\u0026lt; \u0026#34; ns)\u0026#34;\r\n              \u0026lt;\u0026lt; std::endl;\r\n}\r\n\r\nint main() {\r\n    std::cout \u0026lt;\u0026lt; \u0026#34;Sleep 시간 테스트 시작...\\n\u0026#34; \u0026lt;\u0026lt; std::endl;\r\n\r\n    // 나노초 테스트 (100ns, 500ns, 1000ns)\r\n    testSleep(\u0026#34;100 ns\u0026#34;, std::chrono::nanoseconds(100));\r\n    testSleep(\u0026#34;500 ns\u0026#34;, std::chrono::nanoseconds(500));\r\n    testSleep(\u0026#34;1000 ns\u0026#34;, std::chrono::nanoseconds(1000));\r\n    std::cout \u0026lt;\u0026lt; std::endl;\r\n\r\n    // 마이크로초 테스트 (1μs, 10μs, 100μs)\r\n    testSleep(\u0026#34;1 μs\u0026#34;, std::chrono::microseconds(1));\r\n    testSleep(\u0026#34;10 μs\u0026#34;, std::chrono::microseconds(10));\r\n    testSleep(\u0026#34;100 μs\u0026#34;, std::chrono::microseconds(100));\r\n    std::cout \u0026lt;\u0026lt; std::endl;\r\n\r\n    // 밀리초 테스트 (1ms, 10ms, 100ms)\r\n    testSleep(\u0026#34;1 ms\u0026#34;, std::chrono::milliseconds(1));\r\n    testSleep(\u0026#34;10 ms\u0026#34;, std::chrono::milliseconds(10));\r\n    testSleep(\u0026#34;100 ms\u0026#34;, std::chrono::milliseconds(100));\r\n\r\n    return 0;\r\n}\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e","tags":["usleep","sleep","chrono","nanoseconds","microseconds","milliseconds"],"title":"Time 해상도 체크","type":"post","url":"/2025/10/17/sleep-time-check/","weight":0,"wordcount":487},{"author":null,"categories":["Tech"],"content":"GitHub 리포지토리 분석을 위한 세 가지 강력한 툴, GitIngest, DeepWiki, GitDiagram을 소개합니다. AI 기반 요약부터 시각화까지, 프로젝트 이해도를 높이는 방법을 알아보세요.","date":1758176115,"description":"GitHub 리포지토리 분석을 위한 세 가지 강력한 툴, GitIngest, DeepWiki, GitDiagram을 소개합니다. AI 기반 요약부터 시각화까지, 프로젝트 이해도를 높이는 방법을 알아보세요.","dir":"post/","excerpt_html":"GitHub 리포지토리 분석을 위한 세 가지 강력한 툴, GitIngest, DeepWiki, GitDiagram을 소개합니다. AI 기반 요약부터 시각화까지, 프로젝트 이해도를 높이는 방법을 알아보세요.","excerpt_text":"GitHub 리포지토리 분석을 위한 세 가지 강력한 툴, GitIngest, DeepWiki, GitDiagram을 소개합니다. AI 기반 요약부터 시각화까지, 프로젝트 이해도를 높이는 방법을 알아보세요.","expirydate":-62135596800,"fuzzywordcount":1e3,"html":"GitHub 리포지토리 분석을 위한 세 가지 강력한 툴, GitIngest, DeepWiki, GitDiagram을 소개합니다. AI 기반 요약부터 시각화까지, 프로젝트 이해도를 높이는 방법을 알아보세요.","keywords":null,"kind":"page","lang":"en","lastmod":1758176115,"objectID":"6a1938c4c6c7a9fdef6881d99edfb4c7","permalink":"https://hybridego.github.io/2025/09/18/github-project-analyzer/","publishdate":"2025-09-18T15:15:15+09:00","readingtime":2,"relpermalink":"/2025/09/18/github-project-analyzer/","section":"post","summary":"\u003cp\u003eGitHub 리포지토리를 더욱 효과적으로 분석하고 이해하는 데 도움을 줄 수 있는 세 가지 흥미로운 툴을 소개합니다. 이 툴들은 각각 다른 방식으로 리포지토리의 정보를 추출하고 시각화하여 개발자들의 생산성을 높여줄 수 있습니다.\u003c/p\u003e","tags":["GitHub","분석","AI","개발툴","GitIngest","DeepWiki","GitDiagram"],"title":"GitHub 프로젝트 분석 툴 소개","type":"post","url":"/2025/09/18/github-project-analyzer/","weight":0,"wordcount":961},{"author":null,"categories":"Tech","content":"pipewire 기반 pulseAudio 인터페이스","date":1754823683,"description":"pipewire 기반 pulseAudio 인터페이스","dir":"post/","excerpt_html":"pipewire 기반 pulseAudio 인터페이스","excerpt_text":"pipewire 기반 pulseAudio 인터페이스","expirydate":-62135596800,"fuzzywordcount":1100,"html":"pipewire 기반 pulseAudio 인터페이스","keywords":null,"kind":"page","lang":"en","lastmod":1754823683,"objectID":"16008024acf17567272ab527873695de","permalink":"https://hybridego.github.io/2025/08/10/pulseAudio/","publishdate":"2025-08-10T00:00:00Z","readingtime":3,"relpermalink":"/2025/08/10/pulseAudio/","section":"post","summary":"\u003col\u003e\n\u003cli\u003ebuildroot 에 pulseaudio 추가 하고 빌드\u003c/li\u003e\n\u003cli\u003eoutput/nt98567/nt98567 에서\nfd pulse 로 찾음\u003c/li\u003e\n\u003cli\u003e다음의 파일들을 해당 rootfs 위치로 복사\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e$ fd pulse\nusr/bin/pulseaudio\nusr/share/pulseaudio/\nusr/lib/libpulse-mainloop-glib.so.0\nusr/lib/libpulse-mainloop-glib.so\nusr/lib/libpulse-mainloop-glib.so.0.0.6\nusr/lib/libpulse.so.0\nusr/lib/libpulse-simple.so.0.1.1\nusr/lib/libpulse.so\nusr/lib/libpulse.so.0.24.2\nusr/lib/libpulse-simple.so.0\nusr/lib/libpulse-simple.so\netc/init.d/S50pulseaudio\nusr/share/bash-completion/completions/pulseaudio\netc/pulse/\nusr/lib/pulseaudio/\nusr/lib/pulseaudio/libpulsedsp.so\nusr/lib/pulseaudio/libpulsecommon-16.1.so\nusr/lib/pulseaudio/libpulsecore-16.1.so\netc/dbus-1/system.d/pulseaudio-system.conf\nsudo cp -a ./usr /home/lionelj/test/ipas/bwc_firmware/nt98567_2/\nsudo cp -a ./etc/pulse /home/lionelj/test/ipas/bwc_firmware/nt98567_2/etc/\nsudo cp -a ./etc/dbus-1/system.d/pulseaudio-system.conf /home/lionelj/test/ipas/bwc_firmware/nt98567_2/etc/dbus-1/system.d/\nsudo cp -a ./etc/init.d/S50pulseaudio /home/lionelj/test/ipas/bwc_firmware/nt98567_2/etc/init.d/\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e\u003ccode\u003erm /etc/init.d/S25_Net\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003edbus 세팅\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e/etc/dbus-1/system.d/pulseaudio-system.conf 수정\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt;\u0026lt;!--*-nxml-*--\u0026gt;\n\u0026lt;!DOCTYPE busconfig PUBLIC \u0026#34;-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN\u0026#34;\n \u0026#34;http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd\u0026#34;\u0026gt;\n\u0026lt;!--\nThis file is part of PulseAudio.\nPulseAudio is free software; you can redistribute it and/or modify it\nunder the terms of the GNU Lesser General Public License as\npublished by the Free Software Foundation; either version 2.1 of the\nLicense, or (at your option) any later version.\nPulseAudio is distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General\nPublic License for more details.\nYou should have received a copy of the GNU Lesser General Public\nLicense along with PulseAudio; if not, see \u0026lt;http://www.gnu.org/licenses/\u0026gt;.\n--\u0026gt;\n\u0026lt;busconfig\u0026gt;\n  \u0026lt;!-- System-wide PulseAudio runs as \u0026#39;pulse\u0026#39; user. This fragment is\n       not necessary for user PulseAudio instances. --\u0026gt;\n  \u0026lt;policy user=\u0026#34;pulse\u0026#34;\u0026gt;\n    \u0026lt;allow own=\u0026#34;org.pulseaudio.Server\u0026#34;/\u0026gt;\n  \u0026lt;/policy\u0026gt;\n  \u0026lt;policy at_console=\u0026#34;true\u0026#34;\u0026gt;\n    \u0026lt;allow send_destination=\u0026#34;org.pulseaudio.Server\u0026#34;/\u0026gt;\n  \u0026lt;/policy\u0026gt;\n  \u0026lt;policy context=\u0026#34;default\u0026#34;\u0026gt;\n    \u0026lt;deny send_destination=\u0026#34;org.pulseaudio.Server\u0026#34;/\u0026gt;\n  \u0026lt;/policy\u0026gt;\n\u0026lt;/busconfig\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003edbus 재시작\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003ekillall dbus-daemon\ndbus-daemon --system --nofork --nopidfile \u0026amp;\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003epulseAudio 세팅\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003eecho \u0026#34;pulse:x:999:\u0026#34; \u0026gt;\u0026gt; /etc/group\necho \u0026#34;pulse-access:x:1001:root\u0026#34; \u0026gt;\u0026gt; /etc/group\necho \u0026#34;pulse:x:999:999:PulseAudio User:/var/run/pulse:/sbin/nologin\u0026#34; \u0026gt;\u0026gt; /etc/passwd\necho \u0026#34;pulse:*:18800:0:99999:7:::\u0026#34; \u0026gt;\u0026gt; /etc/shadow\nmkdir -p /var/run/pulse /var/lib/pulse\nchown -R pulse:pulse /var/run/pulse /var/lib/pulse\n👉\nchmod -R 755 /var/run/pulse /var/lib/pulse\nchown pulse:pulse /etc/pulse/system.pa\nchmod 644 /etc/pulse/system.pa\nchown pulse:pulse /etc/pulse/client.conf\nchmod 644 /etc/pulse/client.conf\n# audio 그룹에 pulse 추가\nsed -i \u0026#39;s/^audio:x:[0-9]*:/\u0026amp;pulse,/\u0026#39; /etc/group\nexport XDG_RUNTIME_DIR=/run/user/0\nmkdir -p /run/user/0\nchown root:root /run/user/0\n# pulse 사용자가 ALSA 장치에 접근할 수 있도록:\n👉\nchown pulse:pulse /dev/snd/*\nchmod 660 /dev/snd/*\nexport PULSE_RUNTIME_PATH=/var/run/pulse\nexport PULSE_CLIENTCONFIG=/etc/pulse/client.conf\n# Restart PulseAudio and check logs:\npulseaudio --kill\npulseaudio --system --disallow-exit --disallow-module-loading=0 --verbose \u0026amp;\npulseaudio --system --disallow-exit --disallow-module-loading=0 --verbose \u0026gt; pulseaudio.log 2\u0026gt;\u0026amp;1 \u0026amp;\npactl info\npactl list modules | grep -E \u0026#34;null-sink|rtp|combine|alsa\u0026#34;\n# Look for \u0026#39;nvtcard\u0026#39;, \u0026#39;rtp_multicast\u0026#39;, \u0026#39;combined\u0026#39;\npactl list sinks\npaplay --device=combined golden.mp3\npaplay --device=combined ./sine_48_le16s_1ch.wav\npaplay --device=nvtcard ./sine_48_le16s_1ch.wav\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e/etc/pulse/default.pa 수정\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e# module-detect를 주석 처리하여 자동 탐지 비활성화:\n#load-module module-detect\n# ALSA 싱크/소스 명시적으로 추가:\nload-module module-alsa-sink device=hw:0,0 sink_name=nvtcard\nload-module module-alsa-source device=hw:0,0\n- device=hw:0,0: aplay -l에서 확인된 card 0: nvtcard, device 0.\n- sink_name=nvtcard: PulseAudio에서 사용할 이름.\n- RTP 스트리밍을 위해 추가:\nload-module module-null-sink sink_name=rtp_multicast\nload-module module-rtp-send source=rtp_multicast.monitor destination=224.0.0.56 port=4010 loop=0\n- 자체 재생과 스트리밍 동시 지원을 위해 module-combine-sink 추가:\nload-module module-combine-sink sink_name=combined slaves=nvtcard,rtp_multicast\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e/etc/pulse/default.pa 수정 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e# Disable auto detection to avoid failures\n#load-module module-detect\n# Load ALSA sink for local playback\nload-module module-alsa-sink device=hw:0,0 sink_name=nvtcard\n# Load null-sink for RTP streaming\nload-module module-null-sink sink_name=rtp_multicast\n# Load RTP send module\nload-module module-rtp-send source=rtp_multicast.monitor destination=224.0.0.56 port=4010 loop=0\n# Combine for simultaneous local \u0026#43; RTP output\nload-module module-combine-sink sink_name=combined slaves=nvtcard,rtp_multicast\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch1 id=\"수신-디바이스\"\u003e수신 디바이스\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e# rtp_recv 용 null-sink 추가\npactl unload-module module-rtp-recv\npactl load-module module-rtp-recv sap_address=224.0.0.56 sink=nvtcard\npactl load-module module-rtp-recv sap_address=224.0.0.56 sink=nvtcard latency_msec=10\npaplay --device=rtp_multicast /root/sine8.wav\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch1 id=\"로딩된-모듈-리스트-확인\"\u003e로딩된 모듈 리스트 확인\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003epactl list short modules\npactl list module\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch1 id=\"기본-소스-확인\"\u003e기본 소스 확인:\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003esource=default는 현재 시스템의 기본 소스를 사용합니다. 어떤 소스가 기본인지 확인하려면 pactl list sources short 명령을 실행해 보세요. 예를 들어, 마이크 입력을 사용하려면 해당 소스 이름을 명시적으로 지정(예: source=alsa_input.hw:0,0)하는 것이 더 안전할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003epactl list sources short\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch1 id=\"inittab-에-추가\"\u003einittab 에 추가\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e# PulseAudio를 pulse 유저 대신 root로 실행하도록 설정.\n# Buildroot init 스크립트(/etc/init.d/pulseaudio)나 inittab에 추가:\n::respawn:/usr/bin/pulseaudio --system --daemonize --high-priority=no --realtime=no -nF /etc/pulse/system.pa\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch1 id=\"ntp-설정-target-에서\"\u003entp 설정 (target 에서)\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003ebusybox ntpd -p 192.168.71.41 -g -n\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch1 id=\"ffmpeg-변환\"\u003effmpeg 변환\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003effmpeg -i test.mp3 -t 30 -c:a pcm_s16le test_30s.wav\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch2 id=\"명령어\"\u003e명령어\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003echown pulse:pulse /dev/snd/*\nchmod -R 755 /var/run/pulse /var/lib/pulse\nchmod 660 /dev/snd/*\nexport PULSE_RUNTIME_PATH=/var/run/pulse\nexport PULSE_CLIENTCONFIG=/etc/pulse/client.conf\npulseaudio --kill\npulseaudio --system --disallow-exit --disallow-module-loading=0 --verbose \u0026amp;\npulseaudio --system --disallow-exit --disallow-module-loading=0 --log-level=info \u0026amp;\npulseaudio --system --disallow-exit --disallow-module-loading=0 \u0026amp;\nbusybox ntpd -p 192.168.71.41 -g -n\npaplay --device=rtp_multicast ./sine_48_le16s_1ch.wav\npaplay --device=nvtcard ./sine_48_le16s_1ch.wav\npaplay --device=combined ./sine_48_le16s_1ch.wav\npactl unload-module module-rtp-recv\npactl load-module module-rtp-recv sap_address=224.0.0.56 sink=nvtcard latency_msec=200\npactl load-module module-rtp-recv sink=nvtcard latency_msec=200\npactl list sinks short\npactl list sources short\npactl list modules short\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e필요한것\u003c/p\u003e","tags":["linux","pipeWire","ALSA","pulseAudio","JACK"],"title":"PulseAudio 사용 multicast 구현","type":"post","url":"/2025/08/10/pulseAudio/","weight":0,"wordcount":1032},{"author":null,"categories":"Tech","content":"PipeWire의 탄생 배경, 발전 과정, 주요 채택 사례와 함께, 기존 PulseAudio·JACK 대비 강점 및 리눅스 오디오 환경에서의 혁신적 변화를 소개합니다.","date":1752984083,"description":"PipeWire의 탄생 배경, 발전 과정, 주요 채택 사례와 함께, 기존 PulseAudio·JACK 대비 강점 및 리눅스 오디오 환경에서의 혁신적 변화를 소개합니다.","dir":"post/","excerpt_html":"PipeWire의 탄생 배경, 발전 과정, 주요 채택 사례와 함께, 기존 PulseAudio·JACK 대비 강점 및 리눅스 오디오 환경에서의 혁신적 변화를 소개합니다.","excerpt_text":"PipeWire의 탄생 배경, 발전 과정, 주요 채택 사례와 함께, 기존 PulseAudio·JACK 대비 강점 및 리눅스 오디오 환경에서의 혁신적 변화를 소개합니다.","expirydate":-62135596800,"fuzzywordcount":2200,"html":"PipeWire의 탄생 배경, 발전 과정, 주요 채택 사례와 함께, 기존 PulseAudio·JACK 대비 강점 및 리눅스 오디오 환경에서의 혁신적 변화를 소개합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1752984083,"objectID":"01203b1518b93b47b7076b15a633f506","permalink":"https://hybridego.github.io/2025/07/16/pipeWire/","publishdate":"2025-07-16T00:00:00Z","readingtime":5,"relpermalink":"/2025/07/16/pipeWire/","section":"post","summary":"\u003ch1 id=\"pipewire\"\u003ePipeWire\u003c/h1\u003e\n\u003ch2 id=\"pipewire의-히스토리\"\u003ePipeWire의 히스토리\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e연도\u003c/th\u003e\n          \u003cth\u003e주요 사건\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2015\u003c/td\u003e\n          \u003ctd\u003eWim Taymans가 개발 시작, 초기 명칭은 PulseVideo/Pinos\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2017\u003c/td\u003e\n          \u003ctd\u003e오디오 기능 추가, 프로젝트 명칭 PipeWire로 확정\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2018.11\u003c/td\u003e\n          \u003ctd\u003e라이선스 MIT로 변경\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2021.04\u003c/td\u003e\n          \u003ctd\u003eFedora 34에서 최초 기본 오디오 서버 채택\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2022~2023\u003c/td\u003e\n          \u003ctd\u003eUbuntu, Pop!_OS, Debian 등 대형 배포판 기본 채택\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2023.11\u003c/td\u003e\n          \u003ctd\u003e버전 1.0 공식 발표\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"탄생-배경과-초기-개발\"\u003e탄생 배경과 초기 개발\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ePipeWire\u003c/strong\u003e는 2015년 Red Hat의 Wim Taymans에 의해 시작된 리눅스용 저지연(low-latency) 멀티미디어 프레임워크입니다.\u003c/p\u003e","tags":["linux","pipeWire","ALSA","pulseAudio","JACK"],"title":"PipeWire - 리눅스 오디오의 새로운 표준","type":"post","url":"/2025/07/16/pipeWire/","weight":0,"wordcount":2111},{"author":null,"categories":"Tech","content":"Snap, Flatpak, AppImage의 설치 방식, 샌드박스 보안, 업데이트 지원, 사용 사례 등 핵심 차이를 한눈에 정리합니다.","date":1752638483,"description":"Snap, Flatpak, AppImage의 설치 방식, 샌드박스 보안, 업데이트 지원, 사용 사례 등 핵심 차이를 한눈에 정리합니다.","dir":"post/","excerpt_html":"Snap, Flatpak, AppImage의 설치 방식, 샌드박스 보안, 업데이트 지원, 사용 사례 등 핵심 차이를 한눈에 정리합니다.","excerpt_text":"Snap, Flatpak, AppImage의 설치 방식, 샌드박스 보안, 업데이트 지원, 사용 사례 등 핵심 차이를 한눈에 정리합니다.","expirydate":-62135596800,"fuzzywordcount":1100,"html":"Snap, Flatpak, AppImage의 설치 방식, 샌드박스 보안, 업데이트 지원, 사용 사례 등 핵심 차이를 한눈에 정리합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1752638483,"objectID":"470ab3bd863085c1dec5efa7a2936316","permalink":"https://hybridego.github.io/2025/07/16/snap-flatpak-appImage/","publishdate":"2025-07-16T00:00:00Z","readingtime":3,"relpermalink":"/2025/07/16/snap-flatpak-appImage/","section":"post","summary":"\u003ch1 id=\"snap-flatpak-appimage-비교-장단점과-차이점\"\u003eSnap, Flatpak, AppImage 비교: 장단점과 차이점\u003c/h1\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e항목\u003c/th\u003e\n          \u003cth\u003eSnap\u003c/th\u003e\n          \u003cth\u003eFlatpak\u003c/th\u003e\n          \u003cth\u003eAppImage\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e주 개발 주체\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eCanonical (Ubuntu)\u003c/td\u003e\n          \u003ctd\u003eRed Hat 등 오픈 커뮤니티\u003c/td\u003e\n          \u003ctd\u003e커뮤니티 (주로 Peter Simon 등)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e설치/실행 방식\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e패키지 매니저(명령어나 Gui 통해)\u003c/td\u003e\n          \u003ctd\u003e패키지 매니저(명령어나 Gui 통해)\u003c/td\u003e\n          \u003ctd\u003e단일 파일 실행(설치 필요 없음)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e샌드박스\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e있음(AppArmor 등 활용, 선택적)\u003c/td\u003e\n          \u003ctd\u003e필수(강력한 샌드박스, Portal 지원)\u003c/td\u003e\n          \u003ctd\u003e없음(추가 도구로 가능)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e자동 업데이트\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e기본 지원(자동)\u003c/td\u003e\n          \u003ctd\u003e기본 지원(자동, 옵션)\u003c/td\u003e\n          \u003ctd\u003e기본 미지원(별도 도구 필요)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e앱 스토어/레포\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e있음(snapcraft.io)\u003c/td\u003e\n          \u003ctd\u003e있음(Flathub 등)\u003c/td\u003e\n          \u003ctd\u003e없음(개별 배포, 다양한 출처)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e네이티브 통합\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e약간 제한적(시각/입력 등 이질감)\u003c/td\u003e\n          \u003ctd\u003e우수(테마/입력 등 네이티브와 유사)\u003c/td\u003e\n          \u003ctd\u003e없음(최소 통합, 휴대용 실행 우수)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e용량·최적화\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e대체로 큼, 느린 시작\u003c/td\u003e\n          \u003ctd\u003e가장 큼, 느린 시작\u003c/td\u003e\n          \u003ctd\u003e가장 작음, 빠른 실행\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e권한 및 보안\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e중간(권한 인터페이스 방식)\u003c/td\u003e\n          \u003ctd\u003e강력(세분화된 권한, Portal)\u003c/td\u003e\n          \u003ctd\u003e약함(별도 조치 없으면 노출 가능)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e포팅/휴대성\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e어느 리눅스나 동작\u003c/td\u003e\n          \u003ctd\u003e어느 리눅스나 동작\u003c/td\u003e\n          \u003ctd\u003e어디서나 단일 파일 실행\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e서버앱 지원\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e가능(서비스 패키지 배포 등)\u003c/td\u003e\n          \u003ctd\u003e한정적(데스크탑 앱 중심)\u003c/td\u003e\n          \u003ctd\u003e제한적(데스크탑 중심)\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"snap\"\u003eSnap\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e장점\u003c/strong\u003e\u003c/p\u003e","tags":["linux","snap","flatpak","appImage"],"title":"Snap, Flatpak, AppImage의 차이와 장단점 비교","type":"post","url":"/2025/07/16/snap-flatpak-appImage/","weight":0,"wordcount":1047},{"author":null,"categories":"Tech","content":"Bash에서 do-while 패턴을 사용하여 무한 루프를 구현하고, 시스템 정보를 주기적으로 확인하는 방법을 소개합니다.","date":1752041603,"description":"Bash에서 do-while 패턴을 사용하여 무한 루프를 구현하고, 시스템 정보를 주기적으로 확인하는 방법을 소개합니다.","dir":"post/","excerpt_html":"Bash에서 do-while 패턴을 사용하여 무한 루프를 구현하고, 시스템 정보를 주기적으로 확인하는 방법을 소개합니다.","excerpt_text":"Bash에서 do-while 패턴을 사용하여 무한 루프를 구현하고, 시스템 정보를 주기적으로 확인하는 방법을 소개합니다.","expirydate":-62135596800,"fuzzywordcount":100,"html":"Bash에서 do-while 패턴을 사용하여 무한 루프를 구현하고, 시스템 정보를 주기적으로 확인하는 방법을 소개합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1752041603,"objectID":"1a19bd99398517d4c6b6b821374d2425","permalink":"https://hybridego.github.io/2025/07/04/How_to_use_do_while_in_shell/","publishdate":"2025-07-09T00:00:00Z","readingtime":1,"relpermalink":"/2025/07/04/How_to_use_do_while_in_shell/","section":"post","summary":"\u003ch1 id=\"how-to-use-do-while-loops-in-shell-scripts\"\u003eHow to Use do-while Loops in Shell Scripts\u003c/h1\u003e\n\u003ch2 id=\"practical-examples-of-infinite-loops-in-bash\"\u003ePractical Examples of Infinite Loops in Bash\u003c/h2\u003e\n\u003ch3 id=\"bash에서-do-while-패턴을-사용하여-무한-루프를-구현하고-시스템-정보를-주기적으로-확인하는-방법을-소개합니다\"\u003eBash에서 do-while 패턴을 사용하여 무한 루프를 구현하고, 시스템 정보를 주기적으로 확인하는 방법을 소개합니다.\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003ewhile true; do cat /sys/devices/platform/f01d0000.adc/iio:device0/in_voltage3_raw; sleep 1; done\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003ewhile true; do cat /sys/devices/platform/f01d0000.adc/iio:device0/in_voltage3_raw; done\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003ewhile true; do free -h; sleep 1; echo \u0026#34;---\u0026#34;; done\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e","tags":["linux","shell","do-while"],"title":"How to Use do-while Loops in Shell Scripts","type":"post","url":"/2025/07/04/How_to_use_do_while_in_shell/","weight":0,"wordcount":87},{"author":null,"categories":"Tech","content":"g++ 명령어로 현재 사용 중인 C++ 표준 버전을 쉽게 확인하는 방법을 안내합니다.","date":1752041483,"description":"g++ 명령어로 현재 사용 중인 C++ 표준 버전을 쉽게 확인하는 방법을 안내합니다.","dir":"post/","excerpt_html":"g++ 명령어로 현재 사용 중인 C++ 표준 버전을 쉽게 확인하는 방법을 안내합니다.","excerpt_text":"g++ 명령어로 현재 사용 중인 C++ 표준 버전을 쉽게 확인하는 방법을 안내합니다.","expirydate":-62135596800,"fuzzywordcount":500,"html":"g++ 명령어로 현재 사용 중인 C++ 표준 버전을 쉽게 확인하는 방법을 안내합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1752041483,"objectID":"99fdeb57560b2d8e239b06eb63f4aa33","permalink":"https://hybridego.github.io/2025/07/04/Cpp_version_check/","publishdate":"2025-07-09T00:00:00Z","readingtime":1,"relpermalink":"/2025/07/04/Cpp_version_check/","section":"post","summary":"\u003ch1 id=\"c-표준-버전-확인하기\"\u003eC++ 표준 버전 확인하기\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003eg++ -std=c++14 -E -dM -x c++ /dev/null | grep '__cplusplus'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 명령은 g++ 컴파일러가 인식하는 C++ 표준 버전을 확인하는 명령입니다. 각 옵션의 역할은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eg++: GNU C++ 컴파일러를 실행합니다.\u003c/li\u003e\n\u003cli\u003e-std=c++14: C++14 표준을 사용하도록 지정합니다. 다른 버전(c++11, c++17 등)으로 변경할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e-E: 전처리 단계만 수행하고 결과를 출력합니다. 컴파일 과정은 생략됩니다.\u003c/li\u003e\n\u003cli\u003e-dM: 전처리된 출력에서 매크로 정의만 포함하도록 지정합니다.\u003c/li\u003e\n\u003cli\u003e-x c++: 입력 파일의 종류를 C++ 소스 코드로 간주합니다.\u003c/li\u003e\n\u003cli\u003e/dev/null: 실제 소스 코드 파일 대신 null 디바이스를 사용합니다. 이는 컴파일러 자체에서 정의된 매크로를 확인하기 위함입니다.\u003c/li\u003e\n\u003cli\u003e| grep \u0026lsquo;__cplusplus\u0026rsquo;: 전처리된 출력에서 __cplusplus 매크로를 검색하여 출력합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e__cplusplus 매크로는 컴파일러가 지원하는 C++ 표준 버전을 나타냅니다. 예를 들어, 출력이 201703L이면 C++17 표준을 지원함을 의미합니다.\u003c/p\u003e","tags":["linux","cpp","c++","g++"],"title":"How to Check the C++ Version in Use","type":"post","url":"/2025/07/04/Cpp_version_check/","weight":0,"wordcount":476},{"author":null,"categories":"Tech","content":"Understanding high-performance I/O functions like readv(), writev(), splice(), sendfile(), and more in Linux and BSD","date":1751600963,"description":"Understanding high-performance I/O functions like readv(), writev(), splice(), sendfile(), and more in Linux and BSD","dir":"post/","excerpt_html":"Understanding high-performance I/O functions like readv(), writev(), splice(), sendfile(), and more in Linux and BSD","excerpt_text":"Understanding high-performance I/O functions like readv(), writev(), splice(), sendfile(), and more in Linux and BSD","expirydate":-62135596800,"fuzzywordcount":1200,"html":"Understanding high-performance I/O functions like readv(), writev(), splice(), sendfile(), and more in Linux and BSD","keywords":null,"kind":"page","lang":"en","lastmod":1751600963,"objectID":"992b26a8dcabaf426f148198a416d68f","permalink":"https://hybridego.github.io/2025/07/04/High-Performance-IO-in-Unix-Systems/","publishdate":"2025-07-04T00:00:00Z","readingtime":3,"relpermalink":"/2025/07/04/High-Performance-IO-in-Unix-Systems/","section":"post","summary":"\u003ch1 id=\"고성능-io를-위한-유닉스-시스템-호출-가이드\"\u003e고성능 I/O를 위한 유닉스 시스템 호출 가이드\u003c/h1\u003e\n\u003cp\u003e유닉스 계열 운영 체제(리눅스, BSD 등)에서 고성능 I/O 작업은 대용량 데이터 전송, 네트워크 서버, 데이터 스트리밍 등에서 필수적입니다. 이번 포스팅에서는 \u003ccode\u003ereadv()\u003c/code\u003e, \u003ccode\u003ewritev()\u003c/code\u003e, \u003ccode\u003esplice()\u003c/code\u003e, \u003ccode\u003esendfile()\u003c/code\u003e, \u003ccode\u003efunopen()\u003c/code\u003e, \u003ccode\u003esendmsg()\u003c/code\u003e, \u003ccode\u003eio_uring\u003c/code\u003e, 그리고 \u003ccode\u003eshm_open\u003c/code\u003e 같은 함수들의 기능과 사용 예시를 정리하며, 리눅스와 BSD에서의 차이점을 살펴봅니다.\u003c/p\u003e","tags":["linux","bsd","io","system-calls","performance"],"title":"High-Performance I/O in Unix Systems","type":"post","url":"/2025/07/04/High-Performance-IO-in-Unix-Systems/","weight":0,"wordcount":1185},{"author":null,"categories":"Tech","content":"최신 버전으로 packager 버전을 올리는 방법","date":1751591003,"description":"최신 버전으로 packager 버전을 올리는 방법","dir":"post/","excerpt_html":"최신 버전으로 packager 버전을 올리는 방법","excerpt_text":"최신 버전으로 packager 버전을 올리는 방법","expirydate":-62135596800,"fuzzywordcount":200,"html":"최신 버전으로 packager 버전을 올리는 방법","keywords":null,"kind":"page","lang":"en","lastmod":1751591003,"objectID":"00408b3928188fe2d90619b4db68e308","permalink":"https://hybridego.github.io/2025/07/04/Buildroot-package-version-up/","publishdate":"2025-07-04T00:00:00Z","readingtime":1,"relpermalink":"/2025/07/04/Buildroot-package-version-up/","section":"post","summary":"\u003ch1 id=\"buildroot-version-변경하는-방법\"\u003ebuildroot version 변경하는 방법\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003emake nt98567_buildroot_defconfig\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003emake clean\nmake \u0026lt;패키지이름\u0026gt;-rebuild\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e패키지의 소스코드를 수정했다면, 캐시를 지우고 빌드해야 합니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003emake \u0026lt;패키지이름\u0026gt;-dirclean\nmake \u0026lt;패키지이름\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003epackagename.mk 에 다음과 같이 써있으면 host 설정에 따르는 것임\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e$(eval $(virtual-package))\n$(eval $(host-virtual-package))\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ehost package 의 버전 확인하기\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003epkg-config --modversion zlib\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch1 id=\"sha256-hash값-구하기\"\u003esha256 hash값 구하기\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003esha256sum 파일이름\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e","tags":["linux","buildroot"],"title":"Buildroot Package version up","type":"post","url":"/2025/07/04/Buildroot-package-version-up/","weight":0,"wordcount":149},{"author":null,"categories":"Tech","content":"강제로 캐시를 비우게 한다.","date":1751438123,"description":"강제로 캐시를 비우게 한다.","dir":"post/","excerpt_html":"강제로 캐시를 비우게 한다.","excerpt_text":"강제로 캐시를 비우게 한다.","expirydate":-62135596800,"fuzzywordcount":300,"html":"강제로 캐시를 비우게 한다.","keywords":null,"kind":"page","lang":"en","lastmod":1751438123,"objectID":"bfd8c3a4c7dc9333251a7ec0d2b6d92c","permalink":"https://hybridego.github.io/2025/07/02/Empty-Buff-Cache/","publishdate":"2025-07-02T00:00:00Z","readingtime":1,"relpermalink":"/2025/07/02/Empty-Buff-Cache/","section":"post","summary":"\u003ch1 id=\"linux-에서-시스템-buff-and-cache-비우기\"\u003elinux 에서 시스템 Buff and Cache 비우기\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e/proc/sys/vm/drop_caches 사용\n리눅스 커널은 /proc/sys/vm/drop_caches 파일을 통해 캐시를 강제로 비울 수 있는 인터페이스를 제공합니다. 이 방법을 사용하려면 \u003cstrong\u003e루트 권한\u003c/strong\u003e이 필요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e# 캐시 비우기 (페이지 캐시만 비움)\necho 1 | tee /proc/sys/vm/drop_caches\n\n# 덴트리(dentries)와 아이노드(inode) 캐시 비우기\necho 2 | tee /proc/sys/vm/drop_caches\n\n# 페이지 캐시, 덴트리, 아이노드 모두 비우기 (가장 강력)\necho 3 | tee /proc/sys/vm/drop_caches\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e강제로 비우는 대신, 큰 메모리를 사용하는 프로그램(예: stress 도구)을 실행해 시스템이 자연스럽게 buff/cache를 비우도록 유도할 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003esudo apt install stress  # 설치 (Ubuntu/Debian 기준)\nstress --vm 1 --vm-bytes 200G  # 200GB 메모리 사용 시뮬레이션\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e","tags":["linux","drop_caches","stress"],"title":"linux 에서 시스템 Buff and Cache 비우기","type":"post","url":"/2025/07/02/Empty-Buff-Cache/","weight":0,"wordcount":253},{"author":null,"categories":"Tech","content":"docker를 만들고 ssh ternneling 으로 vscode retmoe ssh를 붙이는 방법","date":1750230983,"description":"docker를 만들고 ssh ternneling 으로 vscode retmoe ssh를 붙이는 방법","dir":"post/","excerpt_html":"docker를 만들고 ssh ternneling 으로 vscode retmoe ssh를 붙이는 방법","excerpt_text":"docker를 만들고 ssh ternneling 으로 vscode retmoe ssh를 붙이는 방법","expirydate":-62135596800,"fuzzywordcount":900,"html":"docker를 만들고 ssh ternneling 으로 vscode retmoe ssh를 붙이는 방법","keywords":null,"kind":"page","lang":"en","lastmod":1750230983,"objectID":"8526f62d41f1c1df49ef22b49f833782","permalink":"https://hybridego.github.io/2025/06/18/VSCode-RemoteSSH-Docker/","publishdate":"2025-06-18T00:00:00Z","readingtime":2,"relpermalink":"/2025/06/18/VSCode-RemoteSSH-Docker/","section":"post","summary":"\u003ch1 id=\"vscode-remotessh용-docker-생성\"\u003evscode remoteSSH용 docker 생성\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e사용자에게 docker 권한 부여하기\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003esudo usermod -aG docker $USER\nnewgrp docker\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDockerfile 작성\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003eFROM ubuntu:24.04\n\n# Install required packages for minimal build environment and requested tools\nRUN apt-get update \u0026amp;\u0026amp; \\\n    apt-get install -y \\\n    build-essential \\\n    cmake \\\n    clang-tidy \\\n    git \\\n    vim \\\n    sudo \\\n    zsh \\\n    openssh-server \\\n    locales \u0026amp;\u0026amp; \\\n    apt-get clean \u0026amp;\u0026amp; \\\n    rm -rf /var/lib/apt/lists/*\n\n# Configure locale\nRUN locale-gen en_US.UTF-8\nENV LANG en_US.UTF-8\nENV LANGUAGE en_US:en\nENV LC_ALL en_US.UTF-8\n\n# Create user and group (여기에서 1016 은 기존 서버의 userid 번호를 써줍니다.)\nRUN groupadd -g 1016 lionelj \u0026amp;\u0026amp; \\\n    useradd -u 1016 -g 1016 -m -s /bin/zsh lionelj \u0026amp;\u0026amp; \\\n    usermod -aG sudo lionelj\n\n# Configure SSH\nRUN ssh-keygen -A \u0026amp;\u0026amp; \\\n    chmod 600 /etc/ssh/ssh_host_* \u0026amp;\u0026amp; \\\n    chown root:root /etc/ssh/ssh_host_* \u0026amp;\u0026amp; \\\n    mkdir -p /var/run/sshd \u0026amp;\u0026amp; \\\n    chmod 0755 /var/run/sshd \u0026amp;\u0026amp; \\\n    echo \u0026#34;lionelj ALL=(ALL) NOPASSWD:ALL\u0026#34; \u0026gt;\u0026gt; /etc/sudoers.d/lionelj \u0026amp;\u0026amp; \\\n    chmod 0440 /etc/sudoers.d/lionelj \u0026amp;\u0026amp; \\\n    sed -i \u0026#39;s/#Port 22/Port 2222/\u0026#39; /etc/ssh/sshd_config \u0026amp;\u0026amp; \\\n    echo \u0026#34;PasswordAuthentication yes\u0026#34; \u0026gt;\u0026gt; /etc/ssh/sshd_config \u0026amp;\u0026amp; \\\n    echo \u0026#39;lionelj:qwer\u0026#39; | chpasswd\n\n# Expose SSH port\nEXPOSE 2222\n\n# Start SSH server in background and keep container running\nRUN echo \u0026#39;#!/bin/bash\\n\\\n    sudo /usr/sbin/sshd\\n\\\n    if [ $? -ne 0 ]; then\\n\\\n        echo \u0026#34;Failed to start sshd\u0026#34;\\n\\\n        exit 1\\n\\\n    fi\\n\\\n    tail -f /dev/null\u0026#39; \u0026gt; /start.sh \u0026amp;\u0026amp; \\\n    chmod \u0026#43;x /start.sh\n\nCMD [\u0026#34;/start.sh\u0026#34;]\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003edocker build\u003c/p\u003e","tags":["docker","ssh","ternneling","remoteSSH","vscode"],"title":"vscode remoteSSH용 docker 생성","type":"post","url":"/2025/06/18/VSCode-RemoteSSH-Docker/","weight":0,"wordcount":820},{"author":null,"categories":["Tech"],"content":"네트워크에서 유니캐스트(1:1), 멀티캐스트(1:N, 클래스D), 브로드캐스트(전체)와 서브넷 마스크(/xx) 개념을 이해하면 효율적 통신과 관리를 할 수 있다.","date":1749777203,"description":"네트워크에서 유니캐스트(1:1), 멀티캐스트(1:N, 클래스D), 브로드캐스트(전체)와 서브넷 마스크(/xx) 개념을 이해하면 효율적 통신과 관리를 할 수 있다.","dir":"post/","excerpt_html":"네트워크에서 유니캐스트(1:1), 멀티캐스트(1:N, 클래스D), 브로드캐스트(전체)와 서브넷 마스크(/xx) 개념을 이해하면 효율적 통신과 관리를 할 수 있다.","excerpt_text":"네트워크에서 유니캐스트(1:1), 멀티캐스트(1:N, 클래스D), 브로드캐스트(전체)와 서브넷 마스크(/xx) 개념을 이해하면 효율적 통신과 관리를 할 수 있다.","expirydate":-62135596800,"fuzzywordcount":2100,"html":"네트워크에서 유니캐스트(1:1), 멀티캐스트(1:N, 클래스D), 브로드캐스트(전체)와 서브넷 마스크(/xx) 개념을 이해하면 효율적 통신과 관리를 할 수 있다.","keywords":null,"kind":"page","lang":"en","lastmod":1749777203,"objectID":"45b1a13fd5a818aa230791910b37b788","permalink":"https://hybridego.github.io/2025/06/13/Unicast_Broadcast_Multicast_SubnetMask/","publishdate":"2025-06-13T00:00:00Z","readingtime":5,"relpermalink":"/2025/06/13/Unicast_Broadcast_Multicast_SubnetMask/","section":"post","summary":"\u003ch1 id=\"유니캐스트-브로드캐스트-멀티캐스트와-서브넷-마스크\"\u003e유니캐스트, 브로드캐스트, 멀티캐스트와 서브넷 마스크\u003c/h1\u003e\n\u003ch2 id=\"1-유니캐스트와-멀티캐스트의-차이\"\u003e1. 유니캐스트와 멀티캐스트의 차이\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e유니캐스트(Unicast)\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e1:1 통신 방식\u003c/strong\u003e으로, 한 송신자가 한 수신자에게만 데이터를 전송합니다.\u003c/li\u003e\n\u003cli\u003e예시: 웹서핑, 이메일 등 대부분의 인터넷 통신\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e장점:\u003c/strong\u003e 신뢰성 있는 전송이 가능\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e단점:\u003c/strong\u003e 여러 수신자에게 같은 데이터를 보내려면 각각 개별로 전송해야 하므로 네트워크 트래픽이 증가할 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e멀티캐스트(Multicast)\u003c/strong\u003e\u003c/p\u003e","tags":["Unicast","Broadcast","Multicast","SubnetMask"],"title":"Unicast, Broadcast, Multicast, SubnetMask","type":"post","url":"/2025/06/13/Unicast_Broadcast_Multicast_SubnetMask/","weight":0,"wordcount":2044},{"author":null,"categories":"Tech","content":"SNMP의 기능에 대한 간략한 정리와 샘플 코드","date":1749777083,"description":"SNMP의 기능에 대한 간략한 정리와 샘플 코드","dir":"post/","excerpt_html":"SNMP의 기능에 대한 간략한 정리와 샘플 코드","excerpt_text":"SNMP의 기능에 대한 간략한 정리와 샘플 코드","expirydate":-62135596800,"fuzzywordcount":800,"html":"SNMP의 기능에 대한 간략한 정리와 샘플 코드","keywords":null,"kind":"page","lang":"en","lastmod":1749777083,"objectID":"92766b3dfae36a856b461ac2973da1d4","permalink":"https://hybridego.github.io/2025/06/13/SNMP/","publishdate":"2025-06-13T00:00:00Z","readingtime":2,"relpermalink":"/2025/06/13/SNMP/","section":"post","summary":"\u003ch2 id=\"1-snmp-프로토콜로-할-수-있는-것은\"\u003e1. SNMP 프로토콜로 할 수 있는 것은?\u003c/h2\u003e\n\u003cp\u003eSNMP(Simple Network Management Protocol) 프로토콜을 사용하면 네트워크 관리자가 중앙에서 다양한 네트워크 장치(라우터, 스위치, 서버, 프린터 등)를 효과적으로 모니터링하고 관리할 수 있습니다. 구체적으로 SNMP로 할 수 있는 주요 기능은 다음과 같습니다.\u003c/p\u003e","tags":"SNMP","title":"SNMP","type":"post","url":"/2025/06/13/SNMP/","weight":0,"wordcount":727},{"author":null,"categories":["Tech"],"content":"간단히 Hugo를 설치하는 방법을 정리합니다.","date":1748236583,"description":"간단히 Hugo를 설치하는 방법을 정리합니다.","dir":"post/","excerpt_html":"간단히 Hugo를 설치하는 방법을 정리합니다.","excerpt_text":"간단히 Hugo를 설치하는 방법을 정리합니다.","expirydate":-62135596800,"fuzzywordcount":300,"html":"간단히 Hugo를 설치하는 방법을 정리합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1748236583,"objectID":"5e4d5d8b5154b9b5f80e08f48f6e399e","permalink":"https://hybridego.github.io/2025/06/13/Unicast_Broadcast_Multicast_SubnetMask/","publishdate":"2025-06-13T00:00:00Z","readingtime":1,"relpermalink":"/2025/06/13/Unicast_Broadcast_Multicast_SubnetMask/","section":"post","summary":"\u003col\u003e\n\u003cli\u003e\n\u003cp\u003ehugo 설치\n\u003ccode\u003ewinget install Hugo.Hugo.Extended\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ehugo uninstall\n\u003ccode\u003ewinget uninstall --name \u0026quot;Hugo (Extended)\u0026quot;\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003esite 만들기\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003ePS D:\\dev\u0026gt; hugo new site hybridego_playground\nCongratulations! Your new Hugo site was created in D:\\dev\\hybridego_playground.\n\nJust a few more steps...\n\n1. Change the current directory to D:\\dev\\hybridego_playground.\n2. Create or install a theme:\n   - Create a new theme with the command \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34;\n   - Or, install a theme from https://themes.gohugo.io/\n1. Edit hugo.toml, setting the \u0026#34;theme\u0026#34; property to the theme name.\n2. Create new content with the command \u0026#34;hugo new content \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;.\n3. Start the embedded web server with the command \u0026#34;hugo server --buildDrafts\u0026#34;.\n\nSee documentation at https://gohugo.io/.\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003egit 설정 및 테마 설정\u003c/p\u003e","tags":["go","golang","hugo","github","github actions","github.io","blog"],"title":"Hugo install","type":"post","url":"/2025/06/13/Unicast_Broadcast_Multicast_SubnetMask/","weight":0,"wordcount":268},{"author":null,"categories":["Tech"],"content":"cargo install 할 때 SSL 연결 에러 나는 문제 해결","date":1748231543,"description":"cargo install 할 때 SSL 연결 에러 나는 문제 해결","dir":"post/","excerpt_html":"cargo install 할 때 SSL 연결 에러 나는 문제 해결","excerpt_text":"cargo install 할 때 SSL 연결 에러 나는 문제 해결","expirydate":-62135596800,"fuzzywordcount":200,"html":"cargo install 할 때 SSL 연결 에러 나는 문제 해결","keywords":null,"kind":"page","lang":"en","lastmod":1748231543,"objectID":"423b7f7c37f2c89a90d13236bf1a16d4","permalink":"https://hybridego.github.io/2025/05/26/Cargo_troubleshooting/","publishdate":"2025-05-26T00:00:00Z","readingtime":1,"relpermalink":"/2025/05/26/Cargo_troubleshooting/","section":"post","summary":"\u003ch2 id=\"cargo-install-troubleshooting\"\u003eCargo install troubleshooting\u003c/h2\u003e\n\u003cp\u003ecargo로 뭐 설치하려고 할 때\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003ePS D:\\dev\\rust\u0026gt; rustup update\ninfo: syncing channel updates for \u0026#39;stable-x86_64-pc-windows-msvc\u0026#39;\ninfo: checking for self-update\n\n  stable-x86_64-pc-windows-msvc unchanged - rustc 1.87.0 (17067e9ac 2025-05-09)\n\ninfo: cleaning up downloads \u0026amp; tmp directories\nPS D:\\dev\\rust\u0026gt; cargo install create-tauri-app --locked\n    Updating crates.io index\nwarning: spurious network error (3 tries remaining): [35] SSL connect error (schannel: next InitializeSecurityContext failed: CRYPT_E_NO_REVOCATION_CHECK (0x80092012))\nwarning: spurious network error (2 tries remaining): [35] SSL connect error (schannel: next InitializeSecurityContext failed: CRYPT_E_NO_REVOCATION_CHECK (0x80092012))\nwarning: spurious network error (1 tries remaining): [35] SSL connect error (schannel: next InitializeSecurityContext failed: CRYPT_E_NO_REVOCATION_CHECK (0x80092012))\nerror: download of config.json failed\n\nCaused by:\n  failed to download from `https://index.crates.io/config.json`\n\nCaused by:\n  [35] SSL connect error (schannel: next InitializeSecurityContext failed: CRYPT_E_NO_REVOCATION_CHECK (0x80092012))\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e이런 에러가 발생한다면\u003c/p\u003e","tags":["cargo","rust","SSL Connection error"],"title":"Cargo troubleshooting","type":"post","url":"/2025/05/26/Cargo_troubleshooting/","weight":0,"wordcount":172},{"author":null,"categories":["Tech"],"content":"Dioxus 와 Tauri의 간단한 비교","date":1748221883,"description":"Dioxus 와 Tauri의 간단한 비교","dir":"post/","excerpt_html":"Dioxus 와 Tauri의 간단한 비교","excerpt_text":"Dioxus 와 Tauri의 간단한 비교","expirydate":-62135596800,"fuzzywordcount":2100,"html":"Dioxus 와 Tauri의 간단한 비교","keywords":null,"kind":"page","lang":"en","lastmod":1748221883,"objectID":"5e76d7a192bd314468267f789be02794","permalink":"https://hybridego.github.io/2025/05/26/Dioxus_vs_Tauri/","publishdate":"2025-05-26T00:00:00Z","readingtime":4,"relpermalink":"/2025/05/26/Dioxus_vs_Tauri/","section":"post","summary":"\u003ch1 id=\"dioxus와-tauri-비교\"\u003eDioxus와 Tauri 비교\u003c/h1\u003e\n\u003ch2 id=\"dioxus란\"\u003eDioxus란?\u003c/h2\u003e\n\u003cp\u003eDioxus는 Rust로 작성된 풀스택 UI 프레임워크로, React와 유사한 선언적 프로그래밍 모델을 제공합니다. 웹, 데스크톱, 모바일, 서버사이드 렌더링(SSR), LiveView 등 다양한 플랫폼을 단일 코드베이스로 지원합니다. Rust의 메모리 안전성과 성능을 활용하여 빠르고 안정적인 애플리케이션을 개발할 수 있도록 설계되었습니다. Dioxus는 가상 DOM(Virtual DOM)을 사용하여 UI를 효율적으로 관리하며, React의 컴포넌트 기반 아키텍처와 유사한 개발 경험을 제공합니다. 또한, HTML과 CSS를 적극 활용하며, Tailwind CSS와 같은 외부 CSS 라이브러리와의 통합도 지원합니다. 모바일 지원은 Tauri의 Tao와 Wry 라이브러리를 활용하며, 특히 데스크톱과 웹에서 강력한 성능을 발휘합니다.\u003ca href=\"https://dioxuslabs.com/blog/introducing-dioxus/\"\u003e\u003c/a\u003e\u003ca href=\"https://www.syntax-stories.com/2024/12/dioxus-framework.html\"\u003e\u003c/a\u003e\u003c/p\u003e","tags":["Dioxus","Tauri","rust"],"title":"Dioxus vs Tauri","type":"post","url":"/2025/05/26/Dioxus_vs_Tauri/","weight":0,"wordcount":2001},{"author":null,"categories":["Tech"],"content":"리눅스 디버깅 하는 몇가지 방법","date":1747953743,"description":"리눅스 디버깅 하는 몇가지 방법","dir":"post/","excerpt_html":"리눅스 디버깅 하는 몇가지 방법","excerpt_text":"리눅스 디버깅 하는 몇가지 방법","expirydate":-62135596800,"fuzzywordcount":2e3,"html":"리눅스 디버깅 하는 몇가지 방법","keywords":null,"kind":"page","lang":"en","lastmod":1747953743,"objectID":"858ff867aaeb2a5fa180bd38270e43c2","permalink":"https://hybridego.github.io/2025/05/23/Linux_debugging_skil/","publishdate":"2025-05-23T00:00:00Z","readingtime":4,"relpermalink":"/2025/05/23/Linux_debugging_skil/","section":"post","summary":"\u003ch1 id=\"리눅스-환경에서의-메모리-디버깅-스킬\"\u003e리눅스 환경에서의 메모리 디버깅 스킬\u003c/h1\u003e\n\u003cp\u003e이 교육 자료는 리눅스 환경에서 메모리 관련 문제를 디버깅하는 데 필요한 핵심 개념과 도구를 다룹니다. 페이지, 페이지 폴트, 신호(SIGSEGV, SIGBUS), 댕글링 포인터, \u003ccode\u003e/proc\u003c/code\u003e 파일, OOM Killer, Shadow Memory, LD_PRELOAD, RAII를 기반으로 디버깅 스킬을 정리했습니다.\u003c/p\u003e","tags":["linux","debugging","debug","valgind","ASAN","LD_PRELOAD","RAII"],"title":"linux debugging","type":"post","url":"/2025/05/23/Linux_debugging_skil/","weight":0,"wordcount":1980},{"author":null,"categories":["Tech"],"content":"How to setup ssh tunneling to docker container.","date":1747836683,"description":"How to setup ssh tunneling to docker container.","dir":"post/","excerpt_html":"How to setup ssh tunneling to docker container.","excerpt_text":"How to setup ssh tunneling to docker container.","expirydate":-62135596800,"fuzzywordcount":800,"html":"How to setup ssh tunneling to docker container.","keywords":null,"kind":"page","lang":"en","lastmod":1747836683,"objectID":"f3763ae50f78b87fd07a7fc992a89ee5","permalink":"https://hybridego.github.io/2025/05/21/Docker_SSH_tunneling/","publishdate":"2025-05-21T00:00:00Z","readingtime":2,"relpermalink":"/2025/05/21/Docker_SSH_tunneling/","section":"post","summary":"\u003ch2 id=\"docker-와-ssh-터널링-설정\"\u003eDocker 와 ssh 터널링 설정\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e처음 실행 (필요한 디렉토리 mount 하고 이미지와 shell 선택, user 지정)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003edocker run -it \\\n  -v /home/lionelj:/home/lionelj \\\n  --name lj-ubuntu \\\n  -v /opt:/opt \\\n  ubuntu:24.04 \\\n  /bin/bash\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eDocker 에서 필요한 기본 설정\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003eapt-get update \napt-get install -y sudo \napt-get install -y vim git zsh\ngroupadd -g 1016 lionelj \nuseradd -u 1016 -g 1016 -m -s /bin/zsh lionelj\n\nusermod -aG sudo lionelj #사용자를 sudo 그룹에 추가. -a: 기존 그룹을 유지하면서 추가. -G sudo: sudo 그룹에 추가.\n\nsudo apt-get install -y locales\nsudo locale-gen en_US.UTF-8\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e다음부터는 만들어진 container로 접속\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e# container name으로 접속\ndocker start lj-ubuntu\n# container id로 접속\ndocker start 708d99e6c6b9\n\n# start 후 shell로 접속\ndocker exec -it lj-ubuntu /bin/bash\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e컨테이너를 이미지로 만들기 (이렇게 하면 누적된 image를 다 유지해야 함. 중간 image 삭제 불가)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003edocker commit \u0026lt;컨테이너_ID\u0026gt; my-ubuntu:custom\n\n# ex)\n$ docker commit 7a613f013271 lionel-ubuntu:custom\nsha256:ec1a4af2f69aa0b7b9366279979d80b0cce02ffd2b3f1e07f81ded54875f7666\n\n$ docker images\nREPOSITORY      TAG       IMAGE ID       CREATED         SIZE\nlionel-ubuntu   custom    ec1a4af2f69a   6 seconds ago   235MB\nubuntu          24.04     602eb6fb314b   2 weeks ago     78.1MB\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e새로 만든 이미지로 컨테이너 띄우기\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e$ docker images\nREPOSITORY      TAG       IMAGE ID       CREATED          SIZE\nlionel-ubuntu   24.04     fa9ec891a58d   24 seconds ago   235MB\nubuntu          24.04     602eb6fb314b   2 weeks ago      78.1MB\n\ndocker run -it \\\n  -v /home/lionelj:/home/lionelj \\\n  --name lj-ubuntu \\\n  -v /opt:/opt \\\n  lionel-ubuntu:24.04 \\\n  /bin/bash\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003essh 설정 (container에 접속해서 sshd를 띄운다.)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003emkdir /run/sshd \n/usr/sbin/sshd\n\n# 컨테이너는 기본적으로 systemd를 사용하지 않으므로, systemctl 대신 직접 sshd를 실행.\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003col start=\"7\"\u003e\n\u003cli\u003eip 설정 (host 에서 docker container의 ip를 확인한다. ssh 터널링 설정을 해야 하기 때문)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e$ ip addr\n1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n1839: eth0@if1840: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UP group default\n    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0  \u0026lt;\u0026lt;== 이 번호를 확인.\n       valid_lft forever preferred_lft forever\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e또 다른 ip 확인 방법 (host에서)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e$ docker inspect 85d05024ca50 | grep IPAddress\n            \u0026#34;SecondaryIPAddresses\u0026#34;: null,\n            \u0026#34;IPAddress\u0026#34;: \u0026#34;172.17.0.2\u0026#34;,\n                    \u0026#34;IPAddress\u0026#34;: \u0026#34;172.17.0.2\u0026#34;,\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003col start=\"8\"\u003e\n\u003cli\u003e컨테이너 중지 및 삭제 후 포트 매핑 포함하여 재실행\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003edocker run -it --name lj-ubuntu \\\n  -v /home/lionelj:/home/lionelj \\\n  -v /opt:/opt \\\n  --user 1016:1016 \\\n  -p 2222:2222 \\\n  lj-ubuntu-3:24.04 \\\n  /bin/bash\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003col start=\"9\"\u003e\n\u003cli\u003e이미지 이름 바꾸는 방법\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003edocker tag 원래_이미지_이름:태그 새_이미지_이름:태그\ndocker rmi 원래_이미지_이름:태그\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e접속 하는 방법 ssh 터널링 (윈도우에서 설정.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003essh -L 2222:172.17.0.2:2222 lionelj@\u0026lt;호스트_IP\u0026gt;\nssh -L 2222:172.17.0.2:2222 lionelj@192.168.85.15\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eWindows ssh 설정\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003eC:\\Users\\lionel.j\\.ssh\\config 파일을 열고\n\nHost lj-ubuntu\n  HostName localhost\n  User lionelj\n  Port 2222\n\n이렇게 추가 후\nvscode 에서 Remote-SSH: Connect to Host...로 lj-ubuntu 로 접속.\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003chr\u003e\n\u003ch2 id=\"다음부터-사용할-때는-이렇게\"\u003e다음부터 사용할 때는 이렇게\u003c/h2\u003e\n\u003cp\u003e다 설정하면 이렇게 하면 됨.\u003c/p\u003e","tags":["docker","ssh","tunneling","vscode","SSH Remote"],"title":"Docker SSH tunneling","type":"post","url":"/2025/05/21/Docker_SSH_tunneling/","weight":0,"wordcount":787},{"author":null,"categories":["Tech"],"content":"python uv 사용 방법","date":1747404683,"description":"python uv 사용 방법","dir":"post/","excerpt_html":"python uv 사용 방법","excerpt_text":"python uv 사용 방법","expirydate":-62135596800,"fuzzywordcount":600,"html":"python uv 사용 방법","keywords":null,"kind":"page","lang":"en","lastmod":1747404683,"objectID":"9a222376e06c23e34136430570438d7b","permalink":"https://hybridego.github.io/2025/05/16/Python_uv/","publishdate":"2025-05-16T00:00:00Z","readingtime":2,"relpermalink":"/2025/05/16/Python_uv/","section":"post","summary":"\u003ch1 id=\"python-uv-사용법\"\u003ePython UV 사용법\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e회사에서 uv python install 잘 안될 때\n사용 중인 네트워크(예: 회사 네트워크)가 Zscaler, Cisco Umbrella 같은 프록시를 통해 SSL 검사를 수행하고 있을 가능성이 높습니다. 이 경우, 프록시가 중간에 자체 인증서를 삽입하여 uv가 사용하는 기본 인증서 저장소(Mozilla의 webpki-roots)에서 이를 신뢰하지 못해 UnknownIssuer 에러가 발생합니다.\u003c/p\u003e","tags":["python","uv"],"title":"Python uv","type":"post","url":"/2025/05/16/Python_uv/","weight":0,"wordcount":517},{"author":null,"categories":null,"content":null,"date":1546992e3,"description":"","dir":"post/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1e3,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1546992e3,"objectID":"2f05902e7435de187bb5303fb74f55e2","permalink":"https://hybridego.github.io/post/readme/","publishdate":"2019-01-09T00:00:00Z","readingtime":5,"relpermalink":"/post/readme/","section":"post","summary":"\u003ch1 id=\"clean-white-theme-for-hugo\"\u003eClean White Theme for Hugo\u003c/h1\u003e\n\u003cp\u003eCleanWhite is a clean, elegant, but fully functional blog theme for Hugo. Here is a live \u003ca href=\"https://zhaohuabing.com\"\u003edemo site\u003c/a\u003e using this theme.\u003c/p\u003e\n\u003cp\u003eIt is based on \u003ca href=\"https://github.com/Huxpro/huxpro.github.io\"\u003ehuxblog Jekyll Theme\u003c/a\u003e\nand \u003ca href=\"https://github.com/BlackrockDigital/startbootstrap-clean-blog-jekyll\"\u003eClean Blog Jekyll Theme\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThese two upstream projects have done awesome jobs to create a blog theme, what I\u0026rsquo;m doing here is porting it to Hugo, of which I like the simplicity and the much faster compiling speed. Some other features which I think could be useful, such as site search with algolia and proxy for Disqus access in China, have also been built in the CleanWhite theme. Other fancy features of upstream projects are not supported by this Hugo theme, I\u0026rsquo;d like to make it as simple as possible and only focus on blog purpose, at least for now.\nWhile I created this theme, I followed the Hugo theme best practice and tried to make every part of the template as a replaceable partial html, so it could be much easier for you to make your customization based on it.\u003c/p\u003e","tags":null,"title":"Clean White Theme for Hugo","type":"post","url":"/post/readme/","weight":0,"wordcount":944},{"author":null,"categories":["Tech"],"content":"Istio v1alpha3 라우팅 API 및 설계 원칙 소개","date":1528070400,"description":"Istio v1alpha3 라우팅 API 및 설계 원칙 소개","dir":"post/","excerpt_html":"Istio v1alpha3 라우팅 API 및 설계 원칙 소개","excerpt_text":"Istio v1alpha3 라우팅 API 및 설계 원칙 소개","expirydate":-62135596800,"fuzzywordcount":5900,"html":"Istio v1alpha3 라우팅 API 및 설계 원칙 소개","keywords":null,"kind":"page","lang":"en","lastmod":1528070400,"objectID":"419548ad13183dac6d96760c9815824b","permalink":"https://hybridego.github.io/2018/06/04/introducing-the-istio-v1alpha3-routing-api/","publishdate":"2018-06-04T00:00:00Z","readingtime":12,"relpermalink":"/2018/06/04/introducing-the-istio-v1alpha3-routing-api/","section":"post","summary":"\u003cp\u003e지금까지 Istio는 RouteRule, DestinationPolicy, EgressRule, Ingress(Kubernetes의 Ingress 리소스를 직접 사용)의 네 가지 리소스를 포함하는 간단한 트래픽 관리 API를 제공했습니다. 이 API를 통해 사용자는 Istio 서비스 메시 내에서 트래픽을 쉽게 관리할 수 있습니다. 이 API를 통해 사용자는 요청을 특정 서비스 버전으로 라우팅하고, 복원력 테스트를 위해 지연 및 오류를 주입하고, 타임아웃 및 회로 차단기를 추가하는 등 애플리케이션 코드를 수정할 필요 없이 모든 작업을 수행할 수 있습니다.\u003c/p\u003e","tags":["Istio"],"title":"Istio v1alpha3 라우팅 API 소개","type":"post","url":"/2018/06/04/introducing-the-istio-v1alpha3-routing-api/","weight":0,"wordcount":5850},{"author":null,"categories":["Tech"],"content":"6월 1일 아침, Istio 커뮤니티는 0.8 릴리스를 발표했습니다. 일반적인 버그 수정 및 성능 개선 외에, 이 어린이날 선물에는 어떤 기대할 만한 내용이 있을까요? 함께 살펴보겠습니다.","date":1527897600,"description":"6월 1일 아침, Istio 커뮤니티는 0.8 릴리스를 발표했습니다. 일반적인 버그 수정 및 성능 개선 외에, 이 어린이날 선물에는 어떤 기대할 만한 내용이 있을까요? 함께 살펴보겠습니다.","dir":"post/","excerpt_html":"6월 1일 아침, Istio 커뮤니티는 0.8 릴리스를 발표했습니다. 일반적인 버그 수정 및 성능 개선 외에, 이 어린이날 선물에는 어떤 기대할 만한 내용이 있을까요? 함께 살펴보겠습니다.","excerpt_text":"6월 1일 아침, Istio 커뮤니티는 0.8 릴리스를 발표했습니다. 일반적인 버그 수정 및 성능 개선 외에, 이 어린이날 선물에는 어떤 기대할 만한 내용이 있을까요? 함께 살펴보겠습니다.","expirydate":-62135596800,"fuzzywordcount":1900,"html":"6월 1일 아침, Istio 커뮤니티는 0.8 릴리스를 발표했습니다. 일반적인 버그 수정 및 성능 개선 외에, 이 어린이날 선물에는 어떤 기대할 만한 내용이 있을까요? 함께 살펴보겠습니다.","keywords":null,"kind":"page","lang":"en","lastmod":1527897600,"objectID":"5419b65011b3dcb9020c0728e6d70695","permalink":"https://hybridego.github.io/2018/06/02/istio08/","publishdate":"2018-06-02T00:00:00Z","readingtime":4,"relpermalink":"/2018/06/02/istio08/","section":"post","summary":"\u003cblockquote\u003e\n\u003cp\u003e6월 1일 아침, Istio 커뮤니티는 0.8 릴리스를 발표했습니다. 일반적인 버그 수정 및 성능 개선 외에, 이 어린이날 선물에는 어떤 기대할 만한 내용이 있을까요? 함께 살펴보겠습니다.\u003c/p\u003e\n\u003c/blockquote\u003e","tags":["Istio"],"title":"Istio 0.8 릴리스 발표","type":"post","url":"/2018/06/02/istio08/","weight":0,"wordcount":1857},{"author":null,"categories":["Tips"],"content":"내 Ubuntu 데스크톱 설정에 대한 모든 것, 나중에 필요할 경우를 대비한 메모입니다.","date":152712e4,"description":"내 Ubuntu 데스크톱 설정에 대한 모든 것, 나중에 필요할 경우를 대비한 메모입니다.","dir":"post/","excerpt_html":"내 Ubuntu 데스크톱 설정에 대한 모든 것, 나중에 필요할 경우를 대비한 메모입니다.","excerpt_text":"내 Ubuntu 데스크톱 설정에 대한 모든 것, 나중에 필요할 경우를 대비한 메모입니다.","expirydate":-62135596800,"fuzzywordcount":300,"html":"내 Ubuntu 데스크톱 설정에 대한 모든 것, 나중에 필요할 경우를 대비한 메모입니다.","keywords":null,"kind":"page","lang":"en","lastmod":152712e4,"objectID":"acef740336515250f115284b46f1f096","permalink":"https://hybridego.github.io/2018/05/24/set_up_my_ubuntu_desktop/","publishdate":"2018-05-24T00:00:00Z","readingtime":1,"relpermalink":"/2018/05/24/set_up_my_ubuntu_desktop/","section":"post","summary":"\u003ch2 id=\"ssh-키-쌍-생성\"\u003eSSH 키 쌍 생성\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003essh-keygen -C \u0026#34;hybridego@gmail.com\u0026#34;\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch2 id=\"shadowsocks\"\u003eShadowsocks\u003c/h2\u003e\n\u003cp\u003eShadowsocks 설치\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003esudo apt-get install python3-pip\n\nsudo pip3 install shadowsocks\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e다음 내용을 포함하는 \u003ccode\u003econfig/shadowsocks.json\u003c/code\u003e에 구성 파일 생성:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003e{\n\t\u0026#34;server\u0026#34;:\u0026#34;remote-shadowsocks-server-ip-addr\u0026#34;,\n\t\u0026#34;server_port\u0026#34;:443,\n\t\u0026#34;local_address\u0026#34;:\u0026#34;127.0.0.1\u0026#34;,\n\t\u0026#34;local_port\u0026#34;:1080,\n\t\u0026#34;password\u0026#34;:\u0026#34;your-passwd\u0026#34;,\n\t\u0026#34;timeout\u0026#34;:300,\n\t\u0026#34;method\u0026#34;:\u0026#34;aes-256-cfb\u0026#34;,\n\t\u0026#34;fast_open\u0026#34;:false,\n\t\u0026#34;workers\u0026#34;:1\n}\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e로컬 socks 프록시 시작\u003c/p\u003e","tags":["ubuntu"],"title":"내 Ubuntu 데스크톱 설정에 대한 모든 것","type":"post","url":"/2018/05/24/set_up_my_ubuntu_desktop/","weight":0,"wordcount":200},{"author":null,"categories":["Tech"],"content":"일부 외부 타사 시스템은 시스템 내부의 마이크로서비스에 접근해야 할 수 있습니다. 예를 들어 온라인 상점의 경우, 외부 추천 서비스가 상점의 상품 카탈로그 정보를 얻기 위해 시스템에 연결해야 할 수 있습니다. 내부 서비스 간의 접근과 비교하여 외부 시스템의 접근은 엄격한 보안 제어가 필요합니다.","date":1527098400,"description":"일부 외부 타사 시스템은 시스템 내부의 마이크로서비스에 접근해야 할 수 있습니다. 예를 들어 온라인 상점의 경우, 외부 추천 서비스가 상점의 상품 카탈로그 정보를 얻기 위해 시스템에 연결해야 할 수 있습니다. 내부 서비스 간의 접근과 비교하여 외부 시스템의 접근은 엄격한 보안 제어가 필요합니다.","dir":"post/","excerpt_html":"일부 외부 타사 시스템은 시스템 내부의 마이크로서비스에 접근해야 할 수 있습니다. 예를 들어 온라인 상점의 경우, 외부 추천 서비스가 상점의 상품 카탈로그 정보를 얻기 위해 시스템에 연결해야 할 수 있습니다. 내부 서비스 간의 접근과 비교하여 외부 시스템의 접근은 엄격한 보안 제어가 필요합니다.","excerpt_text":"일부 외부 타사 시스템은 시스템 내부의 마이크로서비스에 접근해야 할 수 있습니다. 예를 들어 온라인 상점의 경우, 외부 추천 서비스가 상점의 상품 카탈로그 정보를 얻기 위해 시스템에 연결해야 할 수 있습니다. 내부 서비스 간의 접근과 비교하여 외부 시스템의 접근은 엄격한 보안 제어가 필요합니다.","expirydate":-62135596800,"fuzzywordcount":2900,"html":"일부 외부 타사 시스템은 시스템 내부의 마이크로서비스에 접근해야 할 수 있습니다. 예를 들어 온라인 상점의 경우, 외부 추천 서비스가 상점의 상품 카탈로그 정보를 얻기 위해 시스템에 연결해야 할 수 있습니다. 내부 서비스 간의 접근과 비교하여 외부 시스템의 접근은 엄격한 보안 제어가 필요합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1527098400,"objectID":"bcf92db93ffdd43ba91e4322cf6c6ece","permalink":"https://hybridego.github.io/2018/05/23/external_system_auth/","publishdate":"2018-05-23T18:00:00Z","readingtime":6,"relpermalink":"/2018/05/23/external_system_auth/","section":"post","summary":"\u003ch2 id=\"외부-시스템-접근-제어\"\u003e외부 시스템 접근 제어\u003c/h2\u003e\n\u003cp\u003e사용자 접근 및 마이크로서비스 간 상호 접근 외에도, 외부 타사 시스템도 시스템 내부의 마이크로서비스에 접근해야 할 수 있습니다. 예를 들어 이전 블로그의 온라인 상점 예시에서, 외부 추천 서비스가 상점의 상품 카탈로그 정보를 얻기 위해 시스템에 연결해야 할 수 있습니다. 내부 서비스 간의 접근과 비교하여 외부 시스템의 접근은 엄격한 보안 제어가 필요합니다.\u003c/p\u003e","tags":["Microservice","Security"],"title":"마이크로서비스 보안 성찰록 3부","type":"post","url":"/2018/05/23/external_system_auth/","weight":0,"wordcount":2835},{"author":null,"categories":["Tech"],"content":"사용자로부터의 접근 요청 외에도, 마이크로서비스 애플리케이션 내의 각 마이크로서비스는 서로 많은 접근을 합니다. 애플리케이션 시스템 데이터의 민감도에 따라 시스템 내 마이크로서비스 접근에 대해서도 적절한 보안 제어가 필요합니다.","date":1527087600,"description":"사용자로부터의 접근 요청 외에도, 마이크로서비스 애플리케이션 내의 각 마이크로서비스는 서로 많은 접근을 합니다. 애플리케이션 시스템 데이터의 민감도에 따라 시스템 내 마이크로서비스 접근에 대해서도 적절한 보안 제어가 필요합니다.","dir":"post/","excerpt_html":"사용자로부터의 접근 요청 외에도, 마이크로서비스 애플리케이션 내의 각 마이크로서비스는 서로 많은 접근을 합니다. 애플리케이션 시스템 데이터의 민감도에 따라 시스템 내 마이크로서비스 접근에 대해서도 적절한 보안 제어가 필요합니다.","excerpt_text":"사용자로부터의 접근 요청 외에도, 마이크로서비스 애플리케이션 내의 각 마이크로서비스는 서로 많은 접근을 합니다. 애플리케이션 시스템 데이터의 민감도에 따라 시스템 내 마이크로서비스 접근에 대해서도 적절한 보안 제어가 필요합니다.","expirydate":-62135596800,"fuzzywordcount":2300,"html":"사용자로부터의 접근 요청 외에도, 마이크로서비스 애플리케이션 내의 각 마이크로서비스는 서로 많은 접근을 합니다. 애플리케이션 시스템 데이터의 민감도에 따라 시스템 내 마이크로서비스 접근에 대해서도 적절한 보안 제어가 필요합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1527087600,"objectID":"d7d93ee7d2a2b13ec20c157389fd7a3a","permalink":"https://hybridego.github.io/2018/05/23/service_2_service_auth/","publishdate":"2018-05-23T15:00:00Z","readingtime":5,"relpermalink":"/2018/05/23/service_2_service_auth/","section":"post","summary":"\u003ch2 id=\"서비스-간-인증-및-권한-부여\"\u003e서비스 간 인증 및 권한 부여\u003c/h2\u003e\n\u003cp\u003e사용자로부터의 접근 요청 외에도, 마이크로서비스 애플리케이션 내의 각 마이크로서비스는 서로 많은 접근을 합니다. 다음 시나리오를 포함합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자 간접적으로 트리거되는 마이크로서비스 간 상호 접근\u003cBR\u003e\n예를 들어 온라인 상점 애플리케이션에서 사용자가 장바구니 마이크로서비스에 접근하여 결제할 때, 장바구니 마이크로서비스는 사용자 등급 마이크로서비스에 접근하여 사용자의 회원 등급을 얻어 사용자가 받을 수 있는 쇼핑 할인을 확인해야 할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e사용자 트리거가 아닌 마이크로서비스 간 상호 접근\u003cBR\u003e\n예를 들어 데이터 동기화 또는 백그라운드 정기 작업으로 인한 마이크로서비스 간 상호 접근.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e애플리케이션 시스템의 데이터 민감도에 따라 시스템 내 마이크로서비스 간 상호 접근에 대해 다른 보안 요구 사항이 있을 수 있습니다.\u003c/p\u003e","tags":["Microservice","Security"],"title":"마이크로서비스 보안 성찰록 2부","type":"post","url":"/2018/05/23/service_2_service_auth/","weight":0,"wordcount":2296},{"author":null,"categories":["Tech"],"content":"최근 마이크로서비스 보안 관련 기존 아이디어를 추가로 요약하고 정리하여, 이전 글에서 명확하지 않았던 부분, 예를 들어 서비스 간 인증 및 권한 부여, 서비스 호출 체인에서 사용자 신원 전달 등을 명확히 했습니다. 이 시리즈 블로그에서는 마이크로서비스 보안을 세 부분으로 나누어 체계적으로 설명할 것입니다: 사용자 접근 인증 및 권한 부여, 서비스 간 인증 및 권한 부여, 외부 시스템 접근 제어.","date":1527069600,"description":"최근 마이크로서비스 보안 관련 기존 아이디어를 추가로 요약하고 정리하여, 이전 글에서 명확하지 않았던 부분, 예를 들어 서비스 간 인증 및 권한 부여, 서비스 호출 체인에서 사용자 신원 전달 등을 명확히 했습니다. 이 시리즈 블로그에서는 마이크로서비스 보안을 세 부분으로 나누어 체계적으로 설명할 것입니다: 사용자 접근 인증 및 권한 부여, 서비스 간 인증 및 권한 부여, 외부 시스템 접근 제어.","dir":"post/","excerpt_html":"최근 마이크로서비스 보안 관련 기존 아이디어를 추가로 요약하고 정리하여, 이전 글에서 명확하지 않았던 부분, 예를 들어 서비스 간 인증 및 권한 부여, 서비스 호출 체인에서 사용자 신원 전달 등을 명확히 했습니다. 이 시리즈 블로그에서는 마이크로서비스 보안을 세 부분으로 나누어 체계적으로 설명할 것입니다: 사용자 접근 인증 및 권한 부여, 서비스 간 인증 및 권한 부여, 외부 시스템 접근 제어.","excerpt_text":"최근 마이크로서비스 보안 관련 기존 아이디어를 추가로 요약하고 정리하여, 이전 글에서 명확하지 않았던 부분, 예를 들어 서비스 간 인증 및 권한 부여, 서비스 호출 체인에서 사용자 신원 전달 등을 명확히 했습니다. 이 시리즈 블로그에서는 마이크로서비스 보안을 세 부분으로 나누어 체계적으로 설명할 것입니다: 사용자 접근 인증 및 권한 부여, 서비스 간 인증 및 권한 부여, 외부 시스템 접근 제어.","expirydate":-62135596800,"fuzzywordcount":3800,"html":"최근 마이크로서비스 보안 관련 기존 아이디어를 추가로 요약하고 정리하여, 이전 글에서 명확하지 않았던 부분, 예를 들어 서비스 간 인증 및 권한 부여, 서비스 호출 체인에서 사용자 신원 전달 등을 명확히 했습니다. 이 시리즈 블로그에서는 마이크로서비스 보안을 세 부분으로 나누어 체계적으로 설명할 것입니다: 사용자 접근 인증 및 권한 부여, 서비스 간 인증 및 권한 부여, 외부 시스템 접근 제어.","keywords":null,"kind":"page","lang":"en","lastmod":1527069600,"objectID":"3fc17cbcf909103e423326182d72a807","permalink":"https://hybridego.github.io/2018/05/22/user_authentication_authorization/","publishdate":"2018-05-23T10:00:00Z","readingtime":8,"relpermalink":"/2018/05/22/user_authentication_authorization/","section":"post","summary":"\u003cblockquote\u003e\n\u003cp\u003e최근 마이크로서비스 보안 관련 기존 아이디어를 추가로 요약하고 정리하여, 이전 글에서 명확하지 않았던 부분, 예를 들어 서비스 간 인증 및 권한 부여, 서비스 호출 체인에서 사용자 신원 전달 등을 명확히 했습니다.\u003c/p\u003e","tags":["Microservice","Security"],"title":"마이크로서비스 보안 성찰록 1부","type":"post","url":"/2018/05/22/user_authentication_authorization/","weight":0,"wordcount":3746},{"author":null,"categories":["Tech"],"content":"Kubernetes 1.9 버전은 Admission Webhook(웹 콜백) 확장 메커니즘을 도입했습니다. 웹훅을 통해 개발자는 Kubernetes API 서버의 기능을 매우 유연하게 확장하여 API 서버가 리소스를 생성할 때 리소스를 검증하거나 수정할 수 있습니다. Istio 0.7 버전은 Kubernetes 웹훅을 활용하여 사이드카 자동 주입을 구현했습니다.","date":1527033600,"description":"Kubernetes 1.9 버전은 Admission Webhook(웹 콜백) 확장 메커니즘을 도입했습니다. 웹훅을 통해 개발자는 Kubernetes API 서버의 기능을 매우 유연하게 확장하여 API 서버가 리소스를 생성할 때 리소스를 검증하거나 수정할 수 있습니다. Istio 0.7 버전은 Kubernetes 웹훅을 활용하여 사이드카 자동 주입을 구현했습니다.","dir":"post/","excerpt_html":"Kubernetes 1.9 버전은 Admission Webhook(웹 콜백) 확장 메커니즘을 도입했습니다. 웹훅을 통해 개발자는 Kubernetes API 서버의 기능을 매우 유연하게 확장하여 API 서버가 리소스를 생성할 때 리소스를 검증하거나 수정할 수 있습니다. Istio 0.7 버전은 Kubernetes 웹훅을 활용하여 사이드카 자동 주입을 구현했습니다.","excerpt_text":"Kubernetes 1.9 버전은 Admission Webhook(웹 콜백) 확장 메커니즘을 도입했습니다. 웹훅을 통해 개발자는 Kubernetes API 서버의 기능을 매우 유연하게 확장하여 API 서버가 리소스를 생성할 때 리소스를 검증하거나 수정할 수 있습니다. Istio 0.7 버전은 Kubernetes 웹훅을 활용하여 사이드카 자동 주입을 구현했습니다.","expirydate":-62135596800,"fuzzywordcount":1100,"html":"Kubernetes 1.9 버전은 Admission Webhook(웹 콜백) 확장 메커니즘을 도입했습니다. 웹훅을 통해 개발자는 Kubernetes API 서버의 기능을 매우 유연하게 확장하여 API 서버가 리소스를 생성할 때 리소스를 검증하거나 수정할 수 있습니다. Istio 0.7 버전은 Kubernetes 웹훅을 활용하여 사이드카 자동 주입을 구현했습니다.","keywords":null,"kind":"page","lang":"en","lastmod":1527033600,"objectID":"61cbee2b7380aaa6e9b9f882840da6a0","permalink":"https://hybridego.github.io/2018/05/23/istio-auto-injection-with-webhook/","publishdate":"2018-05-23T00:00:00Z","readingtime":3,"relpermalink":"/2018/05/23/istio-auto-injection-with-webhook/","section":"post","summary":"\u003ch2 id=\"서론\"\u003e서론\u003c/h2\u003e\n\u003chr\u003e\n\u003cp\u003eKubernetes 1.9 버전은 Admission Webhook(웹 콜백) 확장 메커니즘을 도입했습니다. 웹훅을 통해 개발자는 Kubernetes API 서버의 기능을 매우 유연하게 확장하여 API 서버가 리소스를 생성할 때 리소스를 검증하거나 수정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e웹훅 사용의 장점은 API 서버의 소스 코드를 수정하고 다시 컴파일할 필요 없이 기능을 확장할 수 있다는 것입니다. 삽입된 로직은 독립적인 웹 프로세스로 구현되며, 매개변수 방식으로 Kubernetes에 전달되어 Kubernetes가 자체 로직을 처리할 때 확장 로직을 콜백합니다.\u003c/p\u003e\n\u003cp\u003eIstio 0.7 버전은 Kubernetes 웹훅을 활용하여 사이드카 자동 주입을 구현했습니다.\u003c/p\u003e","tags":["Kubernetes","Istio"],"title":"Istio 사이드카 자동 주입 원리","type":"post","url":"/2018/05/23/istio-auto-injection-with-webhook/","weight":0,"wordcount":1095},{"author":null,"categories":["Tech"],"content":null,"date":1526900400,"description":"","dir":"post/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":1500,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1526900400,"objectID":"bf66956078def1376b24541987e8dd17","permalink":"https://hybridego.github.io/2018/05/21/algolia-integration-with-jekyll/","publishdate":"2018-05-21T11:00:00Z","readingtime":3,"relpermalink":"/2018/05/21/algolia-integration-with-jekyll/","section":"post","summary":"\u003cblockquote\u003e\n\u003cp\u003e이 일련의 기사는 \u0026ldquo;비트코인 및 암호화폐 기술\u0026rdquo; 온라인 강좌의 제 노트입니다.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"목차\"\u003e목차\u003c/h2\u003e\n\u003cp\u003e{:.no_toc}\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e목차\n{:toc}\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"스크루지-코인-거래\"\u003e스크루지 코인 거래\u003c/h2\u003e\n\u003cp\u003e스크루지 코인 프로그래밍 과제는 약간 까다롭습니다. 이 강의의 비디오는 일부 구현 세부 사항을 설명하지 않았습니다. 스크루지 코인에서 사용되는 거래 데이터 구조를 이해하는 데 도움이 되도록 이 다이어그램을 그렸습니다.\n\n  \u003cimg src=\"/img/2018-5-20-cryptocurrency_week1_scroogecoin/scroogecoin.png\" alt=\"스크루지 코인\"\u003e\n\n\u003c/p\u003e","tags":["Jekyll:q","Bitcoin"],"title":"Algolia를 사용하여 Gitpage 블로그에 사이트 내 검색 기능 제공","type":"post","url":"/2018/05/21/algolia-integration-with-jekyll/","weight":0,"wordcount":1400},{"author":null,"categories":["Tech"],"content":"Helm을 사용하여 Kubernetes에 배포하는 방법","date":1523872800,"description":"Helm을 사용하여 Kubernetes에 배포하는 방법","dir":"post/","excerpt_html":"Helm을 사용하여 Kubernetes에 배포하는 방법","excerpt_text":"Helm을 사용하여 Kubernetes에 배포하는 방법","expirydate":-62135596800,"fuzzywordcount":500,"html":"Helm을 사용하여 Kubernetes에 배포하는 방법","keywords":null,"kind":"page","lang":"en","lastmod":1523872800,"objectID":"8160a1bd8df0fbf81c4f36a3c6e7d3af","permalink":"https://hybridego.github.io/2018/04/16/using-helm-to-deploy-to-kubernetes/","publishdate":"2018-04-16T10:00:00Z","readingtime":1,"relpermalink":"/2018/04/16/using-helm-to-deploy-to-kubernetes/","section":"post","summary":"\u003ch2 id=\"helm이란\"\u003eHelm이란?\u003c/h2\u003e\n\u003cp\u003eHelm은 Kubernetes 애플리케이션을 관리하는 도구입니다. Helm은 Kubernetes 애플리케이션을 패키징하고 배포하는 데 사용됩니다. Helm은 Kubernetes 애플리케이션을 쉽게 설치, 업그레이드, 롤백할 수 있도록 도와줍니다.\u003c/p\u003e","tags":["Kubernetes","Helm"],"title":"Helm을 사용하여 Kubernetes에 배포하는 방법","type":"post","url":"/2018/04/16/using-helm-to-deploy-to-kubernetes/","weight":0,"wordcount":441},{"author":null,"categories":["Tech"],"content":"API 게이트웨이와 서비스 메시의 관계는 제가 최근에 계속 고민해왔던 문제이며, 동료 및 커뮤니티 친구들과도 몇 차례 논의했습니다. 이 짧은 글은 둘 사이의 유사점과 마이크로서비스 아키텍처에서 이 둘의 다른 용도를 명확하게 요약합니다.","date":1523439120,"description":"API 게이트웨이와 서비스 메시의 관계는 제가 최근에 계속 고민해왔던 문제이며, 동료 및 커뮤니티 친구들과도 몇 차례 논의했습니다. 이 짧은 글은 둘 사이의 유사점과 마이크로서비스 아키텍처에서 이 둘의 다른 용도를 명확하게 요약합니다.","dir":"post/","excerpt_html":"API 게이트웨이와 서비스 메시의 관계는 제가 최근에 계속 고민해왔던 문제이며, 동료 및 커뮤니티 친구들과도 몇 차례 논의했습니다. 이 짧은 글은 둘 사이의 유사점과 마이크로서비스 아키텍처에서 이 둘의 다른 용도를 명확하게 요약합니다.","excerpt_text":"API 게이트웨이와 서비스 메시의 관계는 제가 최근에 계속 고민해왔던 문제이며, 동료 및 커뮤니티 친구들과도 몇 차례 논의했습니다. 이 짧은 글은 둘 사이의 유사점과 마이크로서비스 아키텍처에서 이 둘의 다른 용도를 명확하게 요약합니다.","expirydate":-62135596800,"fuzzywordcount":1900,"html":"API 게이트웨이와 서비스 메시의 관계는 제가 최근에 계속 고민해왔던 문제이며, 동료 및 커뮤니티 친구들과도 몇 차례 논의했습니다. 이 짧은 글은 둘 사이의 유사점과 마이크로서비스 아키텍처에서 이 둘의 다른 용도를 명확하게 요약합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1523439120,"objectID":"10512631762a4eb4fe14a47b7cb61d54","permalink":"https://hybridego.github.io/2018/04/11/service-mesh-vs-api-gateway-ko/","publishdate":"2018-04-11T09:32:00Z","readingtime":4,"relpermalink":"/2018/04/11/service-mesh-vs-api-gateway-ko/","section":"post","summary":"\u003ch2 id=\"서비스-메시-vs-api-게이트웨이\"\u003e서비스 메시 vs API 게이트웨이\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://medium.com/microservices-in-practice/service-mesh-for-microservices-2953109a3c9a\"\u003e이전 서비스 메시 관련 글\u003c/a\u003e에서 저는 서비스 메시와 API 게이트웨이 간의 관계에 대한 몇 가지 질문을 언급했습니다. 이 글에서는 서비스 메시와 API 게이트웨이의 용도에 대해 더 자세히 논의할 예정입니다.\u003c/p\u003e","tags":["Microservice","Service Mesh","API Gateway"],"title":"서비스 메시 vs API 게이트웨이 관계 탐구 (번역)","type":"post","url":"/2018/04/11/service-mesh-vs-api-gateway-ko/","weight":0,"wordcount":1864},{"author":null,"categories":["Tech"],"content":"아키텍처 패턴으로서 마이크로서비스는 복잡한 시스템을 수십에서 수백 개의 작은 서비스로 분할하며, 각 서비스는 독립적인 비즈니스 로직을 구현합니다. 이러한 작은 서비스는 소규모 소프트웨어 엔지니어링 팀이 이해하고 수정하기 쉽고, 언어 및 프레임워크 선택의 유연성을 제공하며, 애플리케이션 개발 및 출시 시간을 단축하고, 다양한 워크로드 및 리소스 요구 사항에 따라 서비스를 독립적으로 확장/축소할 수 있는 이점을 제공합니다. 반면에 애플리케이션이 여러 마이크로서비스 프로세스로 분할되면 프로세스 내 메서드 호출이 프로세스 간 원격 호출로 변경됩니다. 이는 수많은 서비스의 연결, 관리 및 모니터링의 복잡성을 야기합니다. 이 문서에서는 서비스 메시 패턴이 마이크로서비스 아키텍처의 이러한 과제를 어떻게 해결하는지, 그리고 서비스 메시의 대표적인 오픈 소스 프로젝트인 Istio를 소개합니다.","date":1522324800,"description":"아키텍처 패턴으로서 마이크로서비스는 복잡한 시스템을 수십에서 수백 개의 작은 서비스로 분할하며, 각 서비스는 독립적인 비즈니스 로직을 구현합니다. 이러한 작은 서비스는 소규모 소프트웨어 엔지니어링 팀이 이해하고 수정하기 쉽고, 언어 및 프레임워크 선택의 유연성을 제공하며, 애플리케이션 개발 및 출시 시간을 단축하고, 다양한 워크로드 및 리소스 요구 사항에 따라 서비스를 독립적으로 확장/축소할 수 있는 이점을 제공합니다. 반면에 애플리케이션이 여러 마이크로서비스 프로세스로 분할되면 프로세스 내 메서드 호출이 프로세스 간 원격 호출로 변경됩니다. 이는 수많은 서비스의 연결, 관리 및 모니터링의 복잡성을 야기합니다. 이 문서에서는 서비스 메시 패턴이 마이크로서비스 아키텍처의 이러한 과제를 어떻게 해결하는지, 그리고 서비스 메시의 대표적인 오픈 소스 프로젝트인 Istio를 소개합니다.","dir":"post/","excerpt_html":"아키텍처 패턴으로서 마이크로서비스는 복잡한 시스템을 수십에서 수백 개의 작은 서비스로 분할하며, 각 서비스는 독립적인 비즈니스 로직을 구현합니다. 이러한 작은 서비스는 소규모 소프트웨어 엔지니어링 팀이 이해하고 수정하기 쉽고, 언어 및 프레임워크 선택의 유연성을 제공하며, 애플리케이션 개발 및 출시 시간을 단축하고, 다양한 워크로드 및 리소스 요구 사항에 따라 서비스를 독립적으로 확장/축소할 수 있는 이점을 제공합니다. 반면에 애플리케이션이 여러 마이크로서비스 프로세스로 분할되면 프로세스 내 메서드 호출이 프로세스 간 원격 호출로 변경됩니다. 이는 수많은 서비스의 연결, 관리 및 모니터링의 복잡성을 야기합니다. 이 문서에서는 서비스 메시 패턴이 마이크로서비스 아키텍처의 이러한 과제를 어떻게 해결하는지, 그리고 서비스 메시의 대표적인 오픈 소스 프로젝트인 Istio를 소개합니다.","excerpt_text":"아키텍처 패턴으로서 마이크로서비스는 복잡한 시스템을 수십에서 수백 개의 작은 서비스로 분할하며, 각 서비스는 독립적인 비즈니스 로직을 구현합니다. 이러한 작은 서비스는 소규모 소프트웨어 엔지니어링 팀이 이해하고 수정하기 쉽고, 언어 및 프레임워크 선택의 유연성을 제공하며, 애플리케이션 개발 및 출시 시간을 단축하고, 다양한 워크로드 및 리소스 요구 사항에 따라 서비스를 독립적으로 확장/축소할 수 있는 이점을 제공합니다. 반면에 애플리케이션이 여러 마이크로서비스 프로세스로 분할되면 프로세스 내 메서드 호출이 프로세스 간 원격 호출로 변경됩니다. 이는 수많은 서비스의 연결, 관리 및 모니터링의 복잡성을 야기합니다. 이 문서에서는 서비스 메시 패턴이 마이크로서비스 아키텍처의 이러한 과제를 어떻게 해결하는지, 그리고 서비스 메시의 대표적인 오픈 소스 프로젝트인 Istio를 소개합니다.","expirydate":-62135596800,"fuzzywordcount":10200,"html":"아키텍처 패턴으로서 마이크로서비스는 복잡한 시스템을 수십에서 수백 개의 작은 서비스로 분할하며, 각 서비스는 독립적인 비즈니스 로직을 구현합니다. 이러한 작은 서비스는 소규모 소프트웨어 엔지니어링 팀이 이해하고 수정하기 쉽고, 언어 및 프레임워크 선택의 유연성을 제공하며, 애플리케이션 개발 및 출시 시간을 단축하고, 다양한 워크로드 및 리소스 요구 사항에 따라 서비스를 독립적으로 확장/축소할 수 있는 이점을 제공합니다. 반면에 애플리케이션이 여러 마이크로서비스 프로세스로 분할되면 프로세스 내 메서드 호출이 프로세스 간 원격 호출로 변경됩니다. 이는 수많은 서비스의 연결, 관리 및 모니터링의 복잡성을 야기합니다. 이 문서에서는 서비스 메시 패턴이 마이크로서비스 아키텍처의 이러한 과제를 어떻게 해결하는지, 그리고 서비스 메시의 대표적인 오픈 소스 프로젝트인 Istio를 소개합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1522324800,"objectID":"58e1fcbb286268d60015d8695e72e3b4","permalink":"https://hybridego.github.io/2018/03/29/what-is-service-mesh-and-istio/","publishdate":"2018-03-29T12:00:00Z","readingtime":21,"relpermalink":"/2018/03/29/what-is-service-mesh-and-istio/","section":"post","summary":"\u003ch2 id=\"마이크로서비스-아키텍처의-진화\"\u003e마이크로서비스 아키텍처의 진화\u003c/h2\u003e\n\u003cp\u003e아키텍처 패턴으로서 마이크로서비스는 복잡한 시스템을 수십에서 수백 개의 작은 서비스로 분할하며, 각 서비스는 독립적인 비즈니스 로직을 구현합니다. 이러한 작은 서비스는 소규모 소프트웨어 엔지니어링 팀이 이해하고 수정하기 쉽고, 언어 및 프레임워크 선택의 유연성을 제공하며, 애플리케이션 개발 및 출시 시간을 단축하고, 다양한 워크로드 및 리소스 요구 사항에 따라 서비스를 독립적으로 확장/축소할 수 있는 이점을 제공합니다.\u003c/p\u003e\n\u003cp\u003e반면에 애플리케이션이 여러 마이크로서비스 프로세스로 분할되면 프로세스 내 메서드 호출이 프로세스 간 원격 호출로 변경됩니다. 이는 수많은 서비스의 연결, 관리 및 모니터링의 복잡성을 야기합니다.\u003c/p\u003e","tags":["Microservice","Service Mesh","Istio"],"title":"마이크로서비스 아키텍처의 인프라: 서비스 메시와 Istio에 대해 이야기하다","type":"post","url":"/2018/03/29/what-is-service-mesh-and-istio/","weight":0,"wordcount":10181},{"author":null,"categories":["Tips"],"content":"HTTP 프록시 뒤에서 Docker를 사용하는 방법","date":1520964e3,"description":"HTTP 프록시 뒤에서 Docker를 사용하는 방법","dir":"post/","excerpt_html":"HTTP 프록시 뒤에서 Docker를 사용하는 방법","excerpt_text":"HTTP 프록시 뒤에서 Docker를 사용하는 방법","expirydate":-62135596800,"fuzzywordcount":100,"html":"HTTP 프록시 뒤에서 Docker를 사용하는 방법","keywords":null,"kind":"page","lang":"en","lastmod":1520964e3,"objectID":"98b8057999561a04d562f017fde4df05","permalink":"https://hybridego.github.io/2018/03/13/use-docker-behind-http-proxy/","publishdate":"2018-03-13T18:00:00Z","readingtime":1,"relpermalink":"/2018/03/13/use-docker-behind-http-proxy/","section":"post","summary":"\u003ch2 id=\"ubuntu\"\u003eUbuntu\u003c/h2\u003e\n\u003ch3 id=\"docker에서-http-프록시-설정\"\u003eDocker에서 HTTP 프록시 설정\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\n    \u003cdiv class=\"code-toolbar\"\u003e\n        \u003cbutton class=\"copy-code-button\" title=\"Copy to clipboard\"\u003e\n            \u003ci class=\"fas fa-copy\"\u003e\u003c/i\u003e\n        \u003c/button\u003e\n    \u003c/div\u003e\n    \u003cpre\u003e\u003ccode class=\"\"\u003esudo /etc/default/docker\n\nexport http_proxy=\u0026#34;http://127.0.0.1:3128/\u0026#34;\nexport https_proxy=\u0026#34;http://127.0.0.1:3128/\u0026#34;\nexport HTTP_PROXY=\u0026#34;http://127.0.0.1:3128/\u0026#34;\nexport HTTPS_PROXY=\u0026#34;http://127.0.0.1:3128/\u0026#34;\u003c/code\u003e\u003c/pre\u003e\n\u003c/div\u003e","tags":["Tips","Docker"],"title":"HTTP 프록시 뒤에서 Docker를 사용하는 방법","type":"post","url":"/2018/03/13/use-docker-behind-http-proxy/","weight":0,"wordcount":82},{"author":null,"categories":["Tips"],"content":"Vim 팁과 트릭","date":1518174e3,"description":"Vim 팁과 트릭","dir":"post/","excerpt_html":"Vim 팁과 트릭","excerpt_text":"Vim 팁과 트릭","expirydate":-62135596800,"fuzzywordcount":400,"html":"Vim 팁과 트릭","keywords":null,"kind":"page","lang":"en","lastmod":1518174e3,"objectID":"2d0e4272390337188b486ff2335caebb","permalink":"https://hybridego.github.io/2018/02/09/vim-tips/","publishdate":"2018-02-09T11:00:00Z","readingtime":1,"relpermalink":"/2018/02/09/vim-tips/","section":"post","summary":"\u003ch2 id=\"vim-그래픽-치트-시트\"\u003evim 그래픽 치트 시트\u003c/h2\u003e\n\u003cp\u003e\n  \u003cimg src=\"//img/2018-02-09-vim-tips/vi-vim-cheat-sheet.svg\" alt=\"\"\u003e\n\n\u003c/p\u003e","tags":["Tips","Vim"],"title":"Vim 팁","type":"post","url":"/2018/02/09/vim-tips/","weight":0,"wordcount":342},{"author":null,"categories":["Tips"],"content":"sudo 없이 Docker 명령을 실행하는 방법","date":1518170400,"description":"sudo 없이 Docker 명령을 실행하는 방법","dir":"post/","excerpt_html":"sudo 없이 Docker 명령을 실행하는 방법","excerpt_text":"sudo 없이 Docker 명령을 실행하는 방법","expirydate":-62135596800,"fuzzywordcount":200,"html":"sudo 없이 Docker 명령을 실행하는 방법","keywords":null,"kind":"page","lang":"en","lastmod":1518170400,"objectID":"92d7e3e34329f74a5a955e31f5743bae","permalink":"https://hybridego.github.io/2018/02/09/docker-without-sudo/","publishdate":"2018-02-09T10:00:00Z","readingtime":1,"relpermalink":"/2018/02/09/docker-without-sudo/","section":"post","summary":"\u003ch3 id=\"docker-그룹이-아직-존재하지-않으면-추가합니다\"\u003eDocker 그룹이 아직 존재하지 않으면 추가합니다:\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esudo groupadd docker\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"연결된-사용자-user를-docker-그룹에-추가합니다-현재-사용자를-사용하지-않으려면-사용자-이름을-원하는-사용자와-일치하도록-변경하십시오\"\u003e연결된 사용자 \u0026ldquo;$USER\u0026quot;를 docker 그룹에 추가합니다. 현재 사용자를 사용하지 않으려면 사용자 이름을 원하는 사용자와 일치하도록 변경하십시오:\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esudo gpasswd -a $USER docker\u003c/code\u003e\u003c/p\u003e","tags":["Tips","Docker"],"title":"sudo 없이 Docker 명령을 실행하는 방법","type":"post","url":"/2018/02/09/docker-without-sudo/","weight":0,"wordcount":140},{"author":null,"categories":["Tech"],"content":"마이크로서비스 아키텍처의 도입은 소규모 개발팀, 개발 주기 단축, 언어 선택의 유연성, 서비스 확장성 향상 등 소프트웨어 애플리케이션에 많은 이점을 가져다주었습니다. 동시에 분산 시스템의 복잡한 문제들도 함께 도입되었습니다. 그중 하나의 과제는 마이크로서비스 아키텍처에서 유연하고 안전하며 효율적인 인증 및 권한 부여 방안을 구현하는 것입니다. 이 글에서는 이 문제에 대해 비교적 완전한 논의를 시도할 것입니다.","date":1517659200,"description":"마이크로서비스 아키텍처의 도입은 소규모 개발팀, 개발 주기 단축, 언어 선택의 유연성, 서비스 확장성 향상 등 소프트웨어 애플리케이션에 많은 이점을 가져다주었습니다. 동시에 분산 시스템의 복잡한 문제들도 함께 도입되었습니다. 그중 하나의 과제는 마이크로서비스 아키텍처에서 유연하고 안전하며 효율적인 인증 및 권한 부여 방안을 구현하는 것입니다. 이 글에서는 이 문제에 대해 비교적 완전한 논의를 시도할 것입니다.","dir":"post/","excerpt_html":"마이크로서비스 아키텍처의 도입은 소규모 개발팀, 개발 주기 단축, 언어 선택의 유연성, 서비스 확장성 향상 등 소프트웨어 애플리케이션에 많은 이점을 가져다주었습니다. 동시에 분산 시스템의 복잡한 문제들도 함께 도입되었습니다. 그중 하나의 과제는 마이크로서비스 아키텍처에서 유연하고 안전하며 효율적인 인증 및 권한 부여 방안을 구현하는 것입니다. 이 글에서는 이 문제에 대해 비교적 완전한 논의를 시도할 것입니다.","excerpt_text":"마이크로서비스 아키텍처의 도입은 소규모 개발팀, 개발 주기 단축, 언어 선택의 유연성, 서비스 확장성 향상 등 소프트웨어 애플리케이션에 많은 이점을 가져다주었습니다. 동시에 분산 시스템의 복잡한 문제들도 함께 도입되었습니다. 그중 하나의 과제는 마이크로서비스 아키텍처에서 유연하고 안전하며 효율적인 인증 및 권한 부여 방안을 구현하는 것입니다. 이 글에서는 이 문제에 대해 비교적 완전한 논의를 시도할 것입니다.","expirydate":-62135596800,"fuzzywordcount":6800,"html":"마이크로서비스 아키텍처의 도입은 소규모 개발팀, 개발 주기 단축, 언어 선택의 유연성, 서비스 확장성 향상 등 소프트웨어 애플리케이션에 많은 이점을 가져다주었습니다. 동시에 분산 시스템의 복잡한 문제들도 함께 도입되었습니다. 그중 하나의 과제는 마이크로서비스 아키텍처에서 유연하고 안전하며 효율적인 인증 및 권한 부여 방안을 구현하는 것입니다. 이 글에서는 이 문제에 대해 비교적 완전한 논의를 시도할 것입니다.","keywords":null,"kind":"page","lang":"en","lastmod":1517659200,"objectID":"c1d32da205ea082b3dd7061c39ea7e8b","permalink":"https://hybridego.github.io/2018/05/22/user_authentication_authorization/","publishdate":"2018-02-03T12:00:00Z","readingtime":14,"relpermalink":"/2018/05/22/user_authentication_authorization/","section":"post","summary":"\u003ch2 id=\"서론\"\u003e서론\u003c/h2\u003e\n\u003cp\u003e마이크로서비스 아키텍처의 도입은 소프트웨어 애플리케이션에 많은 이점을 가져다주었습니다: 소규모 개발팀, 개발 주기 단축, 언어 선택의 유연성, 서비스 확장성 향상 등. 동시에 분산 시스템의 복잡한 문제들도 함께 도입되었습니다. 그중 하나의 과제는 마이크로서비스 아키텍처에서 유연하고 안전하며 효율적인 인증 및 권한 부여 방안을 구현하는 것입니다. 이 글에서는 이 문제에 대해 비교적 완전한 논의를 시도할 것입니다.\u003c/p\u003e","tags":["Microservice","Security"],"title":"안전한 마이크로서비스 애플리케이션을 구축하는 방법은?","type":"post","url":"/2018/05/22/user_authentication_authorization/","weight":0,"wordcount":6776},{"author":null,"categories":["Tech"],"content":"Nginmesh는 Istio 서비스 메시 플랫폼의 데이터 플레인 프록시로 사용되는 NGINX의 오픈소스 서비스 메시 프로젝트입니다. 이는 7계층 로드 밸런싱 및 서비스 라우팅 기능을 제공하며, Istio와 사이드카로 통합되어 '표준적이고 안정적이며 안전한 방식'으로 서비스 간 통신을 용이하게 하는 것을 목표로 합니다. Nginmesh는 연말에 0.2 및 0.3 버전을 연속으로 출시하여 서비스 디스커버리, 요청 전달, 라우팅 규칙, 성능 지표 수집 등의 기능을 제공합니다. 이 문서에서는 kubeadm을 사용하여 Kubernetes 클러스터를 설치하고 Nginmesh 사이드카를 배포하는 방법을 설명합니다.","date":1514894400,"description":"Nginmesh는 Istio 서비스 메시 플랫폼의 데이터 플레인 프록시로 사용되는 NGINX의 오픈소스 서비스 메시 프로젝트입니다. 이는 7계층 로드 밸런싱 및 서비스 라우팅 기능을 제공하며, Istio와 사이드카로 통합되어 '표준적이고 안정적이며 안전한 방식'으로 서비스 간 통신을 용이하게 하는 것을 목표로 합니다. Nginmesh는 연말에 0.2 및 0.3 버전을 연속으로 출시하여 서비스 디스커버리, 요청 전달, 라우팅 규칙, 성능 지표 수집 등의 기능을 제공합니다. 이 문서에서는 kubeadm을 사용하여 Kubernetes 클러스터를 설치하고 Nginmesh 사이드카를 배포하는 방법을 설명합니다.","dir":"post/","excerpt_html":"Nginmesh는 Istio 서비스 메시 플랫폼의 데이터 플레인 프록시로 사용되는 NGINX의 오픈소스 서비스 메시 프로젝트입니다. 이는 7계층 로드 밸런싱 및 서비스 라우팅 기능을 제공하며, Istio와 사이드카로 통합되어 '표준적이고 안정적이며 안전한 방식'으로 서비스 간 통신을 용이하게 하는 것을 목표로 합니다. Nginmesh는 연말에 0.2 및 0.3 버전을 연속으로 출시하여 서비스 디스커버리, 요청 전달, 라우팅 규칙, 성능 지표 수집 등의 기능을 제공합니다. 이 문서에서는 kubeadm을 사용하여 Kubernetes 클러스터를 설치하고 Nginmesh 사이드카를 배포하는 방법을 설명합니다.","excerpt_text":"Nginmesh는 Istio 서비스 메시 플랫폼의 데이터 플레인 프록시로 사용되는 NGINX의 오픈소스 서비스 메시 프로젝트입니다. 이는 7계층 로드 밸런싱 및 서비스 라우팅 기능을 제공하며, Istio와 사이드카로 통합되어 '표준적이고 안정적이며 안전한 방식'으로 서비스 간 통신을 용이하게 하는 것을 목표로 합니다. Nginmesh는 연말에 0.2 및 0.3 버전을 연속으로 출시하여 서비스 디스커버리, 요청 전달, 라우팅 규칙, 성능 지표 수집 등의 기능을 제공합니다. 이 문서에서는 kubeadm을 사용하여 Kubernetes 클러스터를 설치하고 Nginmesh 사이드카를 배포하는 방법을 설명합니다.","expirydate":-62135596800,"fuzzywordcount":2700,"html":"Nginmesh는 Istio 서비스 메시 플랫폼의 데이터 플레인 프록시로 사용되는 NGINX의 오픈소스 서비스 메시 프로젝트입니다. 이는 7계층 로드 밸런싱 및 서비스 라우팅 기능을 제공하며, Istio와 사이드카로 통합되어 '표준적이고 안정적이며 안전한 방식'으로 서비스 간 통신을 용이하게 하는 것을 목표로 합니다. Nginmesh는 연말에 0.2 및 0.3 버전을 연속으로 출시하여 서비스 디스커버리, 요청 전달, 라우팅 규칙, 성능 지표 수집 등의 기능을 제공합니다. 이 문서에서는 kubeadm을 사용하여 Kubernetes 클러스터를 설치하고 Nginmesh 사이드카를 배포하는 방법을 설명합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1514894400,"objectID":"f12f8e4e5417662ca5f2745b62aadb1e","permalink":"https://hybridego.github.io/2018/01/02/nginmesh-install/","publishdate":"2018-01-02T12:00:00Z","readingtime":6,"relpermalink":"/2018/01/02/nginmesh-install/","section":"post","summary":"\u003ch2 id=\"서문\"\u003e서문\u003c/h2\u003e\n\u003cp\u003eNginmesh는 Istio 서비스 메시 플랫폼의 데이터 플레인 프록시로 사용되는 NGINX의 오픈소스 서비스 메시 프로젝트입니다. 이는 7계층 로드 밸런싱 및 서비스 라우팅 기능을 제공하며, Istio와 사이드카로 통합되어 \u0026lsquo;표준적이고 안정적이며 안전한 방식\u0026rsquo;으로 서비스 간 통신을 용이하게 하는 것을 목표로 합니다. Nginmesh는 연말에 0.2 및 0.3 버전을 연속으로 출시하여 서비스 디스커버리, 요청 전달, 라우팅 규칙, 성능 지표 수집 등의 기능을 제공합니다.\u003c/p\u003e","tags":["Istio","service Mesh","nginmesh"],"title":"Nginx 오픈소스 서비스 메시 컴포넌트 Nginmesh 설치 가이드","type":"post","url":"/2018/01/02/nginmesh-install/","weight":0,"wordcount":2606},{"author":null,"categories":["Tech"],"content":"Kubernetes의 클러스터 네트워크는 사설 네트워크에 속하며, 배포된 애플리케이션은 클러스터 네트워크 내부에서만 접근할 수 있다는 것을 알고 있습니다. 그렇다면 Kubernetes 클러스터의 애플리케이션을 외부 네트워크에 노출하여 외부 사용자에게 서비스를 제공하는 방법은 무엇일까요? 이 글에서는 외부 네트워크에서 Kubernetes 클러스터의 애플리케이션에 접근하는 몇 가지 구현 방식을 탐구합니다.","date":1511870400,"description":"Kubernetes의 클러스터 네트워크는 사설 네트워크에 속하며, 배포된 애플리케이션은 클러스터 네트워크 내부에서만 접근할 수 있다는 것을 알고 있습니다. 그렇다면 Kubernetes 클러스터의 애플리케이션을 외부 네트워크에 노출하여 외부 사용자에게 서비스를 제공하는 방법은 무엇일까요? 이 글에서는 외부 네트워크에서 Kubernetes 클러스터의 애플리케이션에 접근하는 몇 가지 구현 방식을 탐구합니다.","dir":"post/","excerpt_html":"Kubernetes의 클러스터 네트워크는 사설 네트워크에 속하며, 배포된 애플리케이션은 클러스터 네트워크 내부에서만 접근할 수 있다는 것을 알고 있습니다. 그렇다면 Kubernetes 클러스터의 애플리케이션을 외부 네트워크에 노출하여 외부 사용자에게 서비스를 제공하는 방법은 무엇일까요? 이 글에서는 외부 네트워크에서 Kubernetes 클러스터의 애플리케이션에 접근하는 몇 가지 구현 방식을 탐구합니다.","excerpt_text":"Kubernetes의 클러스터 네트워크는 사설 네트워크에 속하며, 배포된 애플리케이션은 클러스터 네트워크 내부에서만 접근할 수 있다는 것을 알고 있습니다. 그렇다면 Kubernetes 클러스터의 애플리케이션을 외부 네트워크에 노출하여 외부 사용자에게 서비스를 제공하는 방법은 무엇일까요? 이 글에서는 외부 네트워크에서 Kubernetes 클러스터의 애플리케이션에 접근하는 몇 가지 구현 방식을 탐구합니다.","expirydate":-62135596800,"fuzzywordcount":5600,"html":"Kubernetes의 클러스터 네트워크는 사설 네트워크에 속하며, 배포된 애플리케이션은 클러스터 네트워크 내부에서만 접근할 수 있다는 것을 알고 있습니다. 그렇다면 Kubernetes 클러스터의 애플리케이션을 외부 네트워크에 노출하여 외부 사용자에게 서비스를 제공하는 방법은 무엇일까요? 이 글에서는 외부 네트워크에서 Kubernetes 클러스터의 애플리케이션에 접근하는 몇 가지 구현 방식을 탐구합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1511870400,"objectID":"62314fd01037305fcf6b8c9ad3b3b02d","permalink":"https://hybridego.github.io/2017/11/28/access-application-from-outside/","publishdate":"2017-11-28T12:00:00Z","readingtime":12,"relpermalink":"/2017/11/28/access-application-from-outside/","section":"post","summary":"\u003ch2 id=\"서론\"\u003e서론\u003c/h2\u003e\n\u003cp\u003eKubernetes의 클러스터 네트워크는 사설 네트워크에 속하며, 배포된 애플리케이션은 클러스터 네트워크 내부에서만 접근할 수 있다는 것을 알고 있습니다. 그렇다면 Kubernetes 클러스터의 애플리케이션을 외부 네트워크에 노출하여 외부 사용자에게 서비스를 제공하는 방법은 무엇일까요? 이 글에서는 외부 네트워크에서 Kubernetes 클러스터의 애플리케이션에 접근하는 몇 가지 구현 방식을 탐구합니다.\u003c/p\u003e","tags":["Kubernetes"],"title":"Kubernetes 클러스터 외부에서 애플리케이션에 접근하는 방법은 무엇인가요?","type":"post","url":"/2017/11/28/access-application-from-outside/","weight":0,"wordcount":5574},{"author":null,"categories":["Tech"],"content":"애플리케이션이 출시된 후, 운영팀이 직면하는 큰 과제 중 하나는 기존 서비스에 영향을 주지 않으면서 업그레이드를 수행하는 방법입니다. 이 문서에서는 Istio를 사용하여 애플리케이션의 카나리 릴리스를 구현하는 방법을 소개합니다.","date":1510153200,"description":"애플리케이션이 출시된 후, 운영팀이 직면하는 큰 과제 중 하나는 기존 서비스에 영향을 주지 않으면서 업그레이드를 수행하는 방법입니다. 이 문서에서는 Istio를 사용하여 애플리케이션의 카나리 릴리스를 구현하는 방법을 소개합니다.","dir":"post/","excerpt_html":"애플리케이션이 출시된 후, 운영팀이 직면하는 큰 과제 중 하나는 기존 서비스에 영향을 주지 않으면서 업그레이드를 수행하는 방법입니다. 이 문서에서는 Istio를 사용하여 애플리케이션의 카나리 릴리스를 구현하는 방법을 소개합니다.","excerpt_text":"애플리케이션이 출시된 후, 운영팀이 직면하는 큰 과제 중 하나는 기존 서비스에 영향을 주지 않으면서 업그레이드를 수행하는 방법입니다. 이 문서에서는 Istio를 사용하여 애플리케이션의 카나리 릴리스를 구현하는 방법을 소개합니다.","expirydate":-62135596800,"fuzzywordcount":3900,"html":"애플리케이션이 출시된 후, 운영팀이 직면하는 큰 과제 중 하나는 기존 서비스에 영향을 주지 않으면서 업그레이드를 수행하는 방법입니다. 이 문서에서는 Istio를 사용하여 애플리케이션의 카나리 릴리스를 구현하는 방법을 소개합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1510153200,"objectID":"320d9f0641802d90086c08b5cf554c4d","permalink":"https://hybridego.github.io/2017/11/08/istio-canary-release-ko/","publishdate":"2017-11-08T15:00:00Z","readingtime":8,"relpermalink":"/2017/11/08/istio-canary-release-ko/","section":"post","summary":"\u003ch2 id=\"카나리-릴리스canary-release-소개\"\u003e카나리 릴리스(Canary Release) 소개\u003c/h2\u003e\n\u003cp\u003e애플리케이션이 출시된 후, 운영팀이 직면하는 큰 과제 중 하나는 기존 서비스에 영향을 주지 않으면서 업그레이드를 수행하는 방법입니다. 제품을 개발해 본 사람이라면 누구나 알겠지만, 출시 전에 아무리 완벽한 자동화 및 수동 테스트를 거쳤더라도 출시 후에는 크고 작은 문제가 발생하기 마련입니다. 머피의 법칙에 따르면, 잘못될 수 있는 버전 릴리스는 반드시 잘못됩니다.\u003c/p\u003e","tags":["Istio"],"title":"Istio를 이용한 카나리 릴리스(Canary Release) 구현","type":"post","url":"/2017/11/08/istio-canary-release-ko/","weight":0,"wordcount":3862},{"author":null,"categories":["Tech"],"content":"이 작업은 애플리케이션 트래픽을 이전 버전의 서비스에서 새 버전으로 점진적으로 마이그레이션하는 방법을 보여줍니다. Istio를 통해 다양한 가중치 규칙(10%, 20%, ··· 100%)을 사용하여 트래픽을 이전 버전 서비스에서 새 버전 서비스로 원활하게 마이그레이션할 수 있습니다.","date":1510012800,"description":"이 작업은 애플리케이션 트래픽을 이전 버전의 서비스에서 새 버전으로 점진적으로 마이그레이션하는 방법을 보여줍니다. Istio를 통해 다양한 가중치 규칙(10%, 20%, ··· 100%)을 사용하여 트래픽을 이전 버전 서비스에서 새 버전 서비스로 원활하게 마이그레이션할 수 있습니다.","dir":"post/","excerpt_html":"이 작업은 애플리케이션 트래픽을 이전 버전의 서비스에서 새 버전으로 점진적으로 마이그레이션하는 방법을 보여줍니다. Istio를 통해 다양한 가중치 규칙(10%, 20%, ··· 100%)을 사용하여 트래픽을 이전 버전 서비스에서 새 버전 서비스로 원활하게 마이그레이션할 수 있습니다.","excerpt_text":"이 작업은 애플리케이션 트래픽을 이전 버전의 서비스에서 새 버전으로 점진적으로 마이그레이션하는 방법을 보여줍니다. Istio를 통해 다양한 가중치 규칙(10%, 20%, ··· 100%)을 사용하여 트래픽을 이전 버전 서비스에서 새 버전 서비스로 원활하게 마이그레이션할 수 있습니다.","expirydate":-62135596800,"fuzzywordcount":1500,"html":"이 작업은 애플리케이션 트래픽을 이전 버전의 서비스에서 새 버전으로 점진적으로 마이그레이션하는 방법을 보여줍니다. Istio를 통해 다양한 가중치 규칙(10%, 20%, ··· 100%)을 사용하여 트래픽을 이전 버전 서비스에서 새 버전 서비스로 원활하게 마이그레이션할 수 있습니다.","keywords":null,"kind":"page","lang":"en","lastmod":1510012800,"objectID":"5ae8190e8b21dc18fae6ba6a26ad2f8e","permalink":"https://hybridego.github.io/2017/11/07/istio-traffic-shifting/","publishdate":"2017-11-07T00:00:00Z","readingtime":3,"relpermalink":"/2017/11/07/istio-traffic-shifting/","section":"post","summary":"\u003cp\u003eIstio에 대한 더 많은 내용은 \u003ca href=\"http://istio.doczh.cn/\"\u003eIstio 중국어 문서\u003c/a\u003e를 참조하십시오.\u003c/p\u003e\n\u003cp\u003e원문은 \u003ca href=\"https://istio.io/docs/tasks/traffic-management/traffic-shifting.html\"\u003eTraffic Shifting\u003c/a\u003e을 참조하십시오.\u003c/p\u003e\n\u003cp\u003e이 작업은 애플리케이션 트래픽을 이전 버전의 서비스에서 새 버전으로 점진적으로 마이그레이션하는 방법을 보여줍니다. Istio를 통해 다양한 가중치 규칙(10%, 20%, ··· 100%)을 사용하여 트래픽을 이전 버전 서비스에서 새 버전 서비스로 원활하게 마이그레이션할 수 있습니다.\u003c/p\u003e","tags":["Istio"],"title":"Istio를 사용하여 애플리케이션 트래픽 전환 구현","type":"post","url":"/2017/11/07/istio-traffic-shifting/","weight":0,"wordcount":1478},{"author":null,"categories":["Tech"],"content":"Istio는 Google, IBM, Lyft에서 개발한 서비스 메시(Service Mesh) 오픈 소스 프로젝트로, Google이 Kubernetes에 이어 내놓은 또 하나의 걸작입니다. 이 글에서는 베어 메탈에서 Istio 및 Bookinfo 예제 프로그램을 처음부터 구축하는 방법을 시연합니다.","date":1509796800,"description":"Istio는 Google, IBM, Lyft에서 개발한 서비스 메시(Service Mesh) 오픈 소스 프로젝트로, Google이 Kubernetes에 이어 내놓은 또 하나의 걸작입니다. 이 글에서는 베어 메탈에서 Istio 및 Bookinfo 예제 프로그램을 처음부터 구축하는 방법을 시연합니다.","dir":"post/","excerpt_html":"Istio는 Google, IBM, Lyft에서 개발한 서비스 메시(Service Mesh) 오픈 소스 프로젝트로, Google이 Kubernetes에 이어 내놓은 또 하나의 걸작입니다. 이 글에서는 베어 메탈에서 Istio 및 Bookinfo 예제 프로그램을 처음부터 구축하는 방법을 시연합니다.","excerpt_text":"Istio는 Google, IBM, Lyft에서 개발한 서비스 메시(Service Mesh) 오픈 소스 프로젝트로, Google이 Kubernetes에 이어 내놓은 또 하나의 걸작입니다. 이 글에서는 베어 메탈에서 Istio 및 Bookinfo 예제 프로그램을 처음부터 구축하는 방법을 시연합니다.","expirydate":-62135596800,"fuzzywordcount":5500,"html":"Istio는 Google, IBM, Lyft에서 개발한 서비스 메시(Service Mesh) 오픈 소스 프로젝트로, Google이 Kubernetes에 이어 내놓은 또 하나의 걸작입니다. 이 글에서는 베어 메탈에서 Istio 및 Bookinfo 예제 프로그램을 처음부터 구축하는 방법을 시연합니다.","keywords":null,"kind":"page","lang":"en","lastmod":1509796800,"objectID":"d993f98f09d7341809e97a3c1ba8e960","permalink":"https://hybridego.github.io/2017/11/04/istio-install_and_example/","publishdate":"2017-11-04T12:00:00Z","readingtime":11,"relpermalink":"/2017/11/04/istio-install_and_example/","section":"post","summary":"\u003ch2 id=\"서비스-메시-소개\"\u003e서비스 메시 소개\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e서비스 메시\u003c/strong\u003e(Service Mesh)는 마이크로서비스 통신 및 관리를 해결하기 위해 등장한 \u003cstrong\u003e아키텍처 패턴\u003c/strong\u003e입니다.\u003c/p\u003e\n\u003cp\u003e서비스 메시는 서비스 간 통신 및 관련 관리 제어 기능을 비즈니스 프로그램에서 인프라 계층으로 이동시켜 비즈니스 로직과 서비스 통신이라는 두 가지 관심사를 완전히 분리합니다. 서비스 메시를 채택하면 애플리케이션 개발자는 애플리케이션 비즈니스 로직에만 집중하고 구현하면 됩니다. 서비스 간 통신(서비스 검색, 통신 신뢰성, 통신 보안, 서비스 라우팅 등)은 서비스 메시 계층에서 처리하며 애플리케이션에 투명하게 제공됩니다.\u003c/p\u003e","tags":["Istio"],"title":"Istio 및 Bookinfo 예제 프로그램 설치 및 사용 후기","type":"post","url":"/2017/11/04/istio-install_and_example/","weight":0,"wordcount":5432},{"author":null,"categories":null,"content":null,"date":1509753600,"description":"","dir":"post/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1509753600,"objectID":"cf37d97d83d29e7c3f79c50c928a7a4d","permalink":"https://hybridego.github.io/2017/11/03/hello-world/","publishdate":"2017-11-04T00:00:00Z","readingtime":1,"relpermalink":"/2017/11/03/hello-world/","section":"post","summary":"\u003cblockquote\u003e\n\u003cp\u003e“Yeah It\u0026rsquo;s on. ”\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"hello-world\"\u003eHello World!\u003c/h2\u003e","tags":null,"title":"Welcome to Lionel Blog","type":"post","url":"/2017/11/03/hello-world/","weight":0,"wordcount":6},{"author":null,"categories":null,"content":null,"date":-62135596800,"description":"","dir":"about/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":700,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"https://hybridego.github.io/about/","publishdate":"0001-01-01T00:00:00Z","readingtime":3,"relpermalink":"/about/","section":"","summary":"\u003ch2 id=\"profile\"\u003eProfile\u003c/h2\u003e\n\u003cp\u003eHoChul Jeon\u003cbr\u003e\n\u003ca href=\"mailto:hybridego@gmail.com\"\u003ehybridego@gmail.com\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"summary\"\u003eSummary\u003c/h2\u003e\n\u003cp\u003eEmbedded systems expert with extensive Linux and Android-based Firmware, Platform, and Server development. Participated in Android porting and platform work from early versions (Cupcake). Deep analysis of Camera, Audio, SurfaceFlinger, Multimedia HAL/Framework, with hands-on projects. Experience in Device Driver porting, Customized Native Services, System mods, NDK apps. Proficient in C/C++, Python, Go, Kotlin for full-stack from embedded to server. Multiple smart speaker, robot, IoT projects.\u003c/p\u003e\n\u003ch2 id=\"technical-stack\"\u003eTechnical Stack\u003c/h2\u003e\n\u003ch3 id=\"languages\"\u003eLanguages\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eC/C++, Python, Go, Java, Kotlin, Rust\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"development\"\u003eDevelopment\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eBuildroot, Yocto, Linux Device Driver, Android HAL/NDK/SDK\u003c/li\u003e\n\u003cli\u003eROS/ROS2, IAR, QT, SDL, Vue3, ESP32 Firmware, Electron (Node.js)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"multimedia\"\u003eMultimedia\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eFFmpeg, GStreamer, ALSA/TinyALSA, DMB, PulseAudio, Pipewire\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"db\"\u003eDB\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eSQLite, MariaDB (MySQL), Neo4j\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"tools\"\u003eTools\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eVim, Android Studio, IntelliJ, VS Code\u003c/li\u003e\n\u003cli\u003eJIRA (Project Mgmt), Git (Version Control)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"certifications\"\u003eCertifications\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eVocational Training Instructor Level 3 (Sep 2009)\u003c/li\u003e\n\u003cli\u003eInformation Processing Technician (Oct 2007)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"publications\"\u003ePublications\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eAll About Android NDK\u003c/em\u003e (2012, Hanbit Media)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"education\"\u003eEducation\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eKorea University of Technology and Education\u003c/strong\u003e\u003cbr\u003e\nB.S., Internet Software Engineering (Multimedia)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"experience\"\u003eExperience\u003c/h2\u003e\n\u003ch3 id=\"hanwha-vision-may-2024--present\"\u003eHanwha Vision (May 2024 – Present)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eBody Worn Camera\u003c/strong\u003e: Field surveillance camera video control (HW Codec).\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: C++, Buildroot, CMake, Python, HW Codec.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePublic Audio System\u003c/strong\u003e: Building broadcast system.\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: C++, PulseAudio, ALSA, Go, Vue, RTP, Multicast, SQLite3.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"hyundai-autoever-sep-2023--may-2024\"\u003eHyundai Autoever (Sep 2023 – May 2024)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCCIC / P-OIP (Android Automotive)\u003c/strong\u003e: OS-Navigation interface (ccIC27, P-OIP).\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: Volley, Android Compose, Kotlin, AIDL, C++, D-Bus, Go, JNI, Android Automotive.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"kakao-enterprise-dec-2019--aug-2023\"\u003eKakao Enterprise (Dec 2019 – Aug 2023)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eKakao Home\u003c/strong\u003e: IoT platform server modernization and third-party integration maintenance.\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: Spring Boot, Kotlin, K8s, Vault, OAuth2, Logstash, Elasticsearch, Kibana, GitHub, MySQL, Redis.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRobot Tech Testing\u003c/strong\u003e: Indoor serving robot device/server dev.\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: ROS/ROS2, SLAM, Cartographer, Navigation2, Go, MQTT, MySQL, KakaoTalk Chatbot.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSmart Office Setup\u003c/strong\u003e: Sensor/dashboard devices, servers, apps.\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: Nordic nRF52840, Matter OpenThread, MQTT-SN, Python (BeautifulSoup, Selenium), Django, Electron, Node.js, Vue3.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKakao Mini Hexa\u003c/strong\u003e: Linux smart speaker porting, Mic Tuning/BMT.\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: Qualcomm QCS404, Yocto Linux, OTA, DSPC solution, Python automation.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKakao Mini C Audio Enhancement\u003c/strong\u003e: Audio tuning, 32bit→64bit migration.\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: GoodHz EQ solution, Android Audio HAL.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"kakao-oct-2014--nov-2019\"\u003eKakao (Oct 2014 – Nov 2019)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eKakao Mini Link\u003c/strong\u003e: IoT device Bluetooth stack mods (BLE, A2DP, HFP).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKakao Mini C\u003c/strong\u003e: Android smart speaker (MT8167, RK3326) dev.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKakao Mini 1st Gen\u003c/strong\u003e: Full Android BSP (NXP4330, porting, HAL, OTA, Aging Test, BT/WiFi, Audio Precision automation).\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: Linux Device Driver, Android Porting, HAL, Native Daemon, SELinux, Android App, BT/WiFi, Audio Precision, Ellisys Bluetooth Vanguard.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIDC Efficiency\u003c/strong\u003e: ESP32 sensor device (power/temp/humidity/airflow collection).\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: ESP32 esp-idf, MQTT, WiFi, Ethernet.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTV Closed Caption Extractor\u003c/strong\u003e: TV TS decoding, caption/audio extraction \u0026amp; streaming.\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: FFmpeg, libiconv, TCP server.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVideo Encoder Accel Server\u003c/strong\u003e: HW encoder testing (Nexel 4330, Nvidia Jetson, FPGA).\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: FFmpeg, GStreamer, NVENC.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSong Recognition Broadcast Receiver Upgrade\u003c/strong\u003e: Linux-based receiver (Android → Linux).\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: Buildroot, TV/Radio Driver, FFmpeg, RTSP, Syslog, MPEG-TS, Audio Resampling, Valgrind.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"daum-communications-jan-2013--sep-2014\"\u003eDaum Communications (Jan 2013 – Sep 2014)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eBluetooth Beacon R\u0026amp;D\u003c/strong\u003e: Event app (treasure hunt).\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: Android SDK, Bluetooth LE.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIndoor Air Quality Collector\u003c/strong\u003e: Node/master firmware, Android app.\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: BLE, Bluetooth Classic, WiFi, IAR, Android SDK.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSong Recognition Broadcast Receiver - Phase 1\u003c/strong\u003e: Android porting (Telechips TCC89xx).\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: TV/Radio Driver, FFmpeg, DMB RTSP, Resampling.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDaum TV\u003c/strong\u003e: Set-top box tech internalization.\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: Telechips Android BSP, TV/Radio Driver.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"insignal-sep-2010--dec-2012-janaug-2010\"\u003eInsignal (Sep 2010 – Dec 2012; Jan–Aug 2010)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTJ Media Japan Android Karaoke Remote\u003c/strong\u003e: Debugging \u0026amp; perf testing.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAndroid Native Framework Training\u003c/strong\u003e: NDK materials (MDS, Samsung, LG, etc.).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAndroid Navigation App\u003c/strong\u003e: DMB driver porting, video player app.\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: Linux Device Driver, Android NDK, FFmpeg.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAndroid Multimedia Engine\u003c/strong\u003e: Early Android video engine (multi-format support).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"other-projects\"\u003eOther Projects\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eHome Appliance Control Test\u003c/strong\u003e: SSDP/UPnP via smart speaker (DDNS, Avahi).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUnmanned Store\u003c/strong\u003e: Camera placement, weight sensing devices.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKT Children\u0026rsquo;s Monkey Robot (Mon-e)\u003c/strong\u003e: Embedded Linux robot control.\u003cbr\u003e\n\u003cem\u003eTech\u003c/em\u003e: SDL, Serial comm, NFC.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eVideo Call Porting\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e","tags":null,"title":"","type":"page","url":"/about/","weight":0,"wordcount":605},{"author":null,"categories":null,"content":null,"date":-62135596800,"description":"","dir":"notes/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"1ede8046f9c3a02d422dea7bbf324e64","permalink":"https://hybridego.github.io/notes/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/notes/","section":"","summary":"\u003ch2 id=\"rust-embedded-devices\"\u003e\u003ca href=\"https://www.rust-lang.org/what/embedded\"\u003eRust Embedded devices\u003c/a\u003e\u003c/h2\u003e\n\u003ch2 id=\"the-rust-programming-language\"\u003e\u003ca href=\"https://doc.rust-kr.org/\"\u003eThe Rust Programming Language\u003c/a\u003e\u003c/h2\u003e\n\u003ch2 id=\"golang-korea\"\u003e\u003ca href=\"https://github.com/golangkorea\"\u003eGolang Korea\u003c/a\u003e\u003c/h2\u003e\n\u003ch2 id=\"effective-go\"\u003e\u003ca href=\"https://github.com/golangkorea/effective-go\"\u003eEffective-go\u003c/a\u003e\u003c/h2\u003e\n\u003ch2 id=\"gophercon-talks\"\u003e\u003ca href=\"https://github.com/golangkorea/gophercon-talks\"\u003egophercon-talks\u003c/a\u003e\u003c/h2\u003e","tags":null,"title":"","type":"page","url":"/notes/","weight":0,"wordcount":11},{"author":null,"categories":null,"content":null,"date":-62135596800,"description":"","dir":"search/","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8946788897930c0c0c39fbfcd30ff2e4","permalink":"https://hybridego.github.io/search/placeholder/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/search/placeholder/","section":"search","summary":"","tags":null,"title":"","type":"search","url":"/search/placeholder/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":"Archive of historical posts.","date":-62135596800,"description":"Archive of historical posts.","dir":"archive/","excerpt_html":"Archive of historical posts.","excerpt_text":"Archive of historical posts.","expirydate":-62135596800,"fuzzywordcount":100,"html":"Archive of historical posts.","keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a06e5ce9eca4c3260843078104889780","permalink":"https://hybridego.github.io/archive/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/archive/","section":"","summary":"","tags":null,"title":"Posts Archive","type":"archive","url":"/archive/","weight":0,"wordcount":0}]